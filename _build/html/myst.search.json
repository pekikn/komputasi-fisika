{"version":"1","records":[{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia"},"type":"lvl1","url":"/materi/pengantar-julia","position":0},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia"},"content":"","type":"content","url":"/materi/pengantar-julia","position":1},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Dasar-dasar Julia"},"type":"lvl2","url":"/materi/pengantar-julia#dasar-dasar-julia","position":2},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Dasar-dasar Julia"},"content":"Scientific Computing memerlukan bahasa pemrograman yang memiliki unjuk kerja tinggi, dan sekaligus sederhana, untuk menyelesaikan suatu permasalahan secara komputasi. Dalam praktek, kedua fitur tersebut sayangnya tidak dapat terpenuhi secara bersamaan. Salah satu komponen penunjang unjuk kerja tinggi adalah berupa sistem compiler, bukan sistem interpreter seperti bahasa Python atau R. Adapun salah satu ciri kemudahan dalam bahasa pemrograman adalah berupa dynamically-typed language, bukan statically-typed language seperti bahasa C.\n\nBahasa pemrograman \n\nJulia dirancang sejak awal untuk memiliki 2 fitur tersebut yaitu memiliki unjuk kerja tinggi dan sederhana dalam penggunaan. Fitur lain dari Julia antara lain:\n\nDikembangkan oleh MIT dengan lisensi yang bersifat free dan open source.\n\nDirancang untuk mendukung komputasi paralel\n\nDidukung dalam penggunaan \n\nUnicode\n\nUraian berikut akan memaparkan secara ringkas tentang sebagian fasilitas yang dimiliki oleh Julia dalam melakukan berbagai perintah (tasks) yang terkait dengan komputasi. Informasi secara lebih lengkap terkait beberapa uraian yang disajikan di bawah maka dapat merujuk pada \n\nDokumentasi Julia.","type":"content","url":"/materi/pengantar-julia#dasar-dasar-julia","position":3},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Sintak untuk Komentar"},"type":"lvl2","url":"/materi/pengantar-julia#sintak-untuk-komentar","position":4},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Sintak untuk Komentar"},"content":"Dalam penulisan suatu bahasa pemrograman, kadang diperlukan mekanisme untuk memberikan komentar agar beberapa bagian dalam source code menjadi lebih jelas. Untuk itu diperlukan suatu penanda untuk membedakan antara suatu perintah dan suatu komentar. Dalam Julia, sintak yang menjadi penanda bagi suatu komentar adalah #.","type":"content","url":"/materi/pengantar-julia#sintak-untuk-komentar","position":5},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Variable"},"type":"lvl2","url":"/materi/pengantar-julia#variable","position":6},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Variable"},"content":"Variable merupakan suatu penamaan yang terkait dengan suatu nilai. Penulisan variable dalam Julia amat fleksibel dan kaya pilihan, yang mampu membedakan antara huruf besar dan kecil serta dapat menggunakan unicode, bahkan mampu menerima kode dalam LaTeX. Berikut adalah contoh penggunaan variable:\n\n# seluruh kata setelah tanda pagar dianggap sebagai komentar, bukan sebagai perintah\nx = 10 \n\n\n\nδ = 13\n\n\n\n® = 5\n\n\n\nDalam ungkapan di atas, simbol LaTeX \\delta dimasukkan dengan mengetik \\delta dan diikuti tekan kunci TAB, sedang simbol Unicode ® dimasukkan dengan mengetik \\circledR dan diikuti tekan kunci TAB.","type":"content","url":"/materi/pengantar-julia#variable","position":7},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"type":"lvl2","url":"/materi/pengantar-julia#bilangan-bulat-dan-pecahan-floating-point","position":8},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"content":"","type":"content","url":"/materi/pengantar-julia#bilangan-bulat-dan-pecahan-floating-point","position":9},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Bilangan Bulat","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"type":"lvl3","url":"/materi/pengantar-julia#bilangan-bulat","position":10},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Bilangan Bulat","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"content":"Secara otomatis (default), jenis bilangan bulat yang digunakan dalam Julia akan tergantung pada tipe bit komputer yang digunakan, yaitu jenis bilangan bulat Int8, Int16, Int32, Int64 atau Int128 untuk komputer bertipe 8, 16, 32, 64 atau 128 bit. Semakin besar tipe bit maka semakin besar pula kemampuan komputer untuk mengakses bilangan bulat maksimum (bilangan bulat positip yang terbesar) dan minimum (bilangan bulat negatip yang terbesar).\n\nx = 2894\n\n\n\ntypeof(x)\n\n\n\n(typemax(Int64), typemin(Int64)) \n\n\n\n(typemax(Int32), typemin(Int32))\n\n\n\n","type":"content","url":"/materi/pengantar-julia#bilangan-bulat","position":11},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Pecahan (Floating Point)","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"type":"lvl3","url":"/materi/pengantar-julia#pecahan-floating-point","position":12},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Pecahan (Floating Point)","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"content":"Seperti halnya bilangan bulat, jenis floating point yang digunakan secara default saat menjalankan komputasi juga ditentukan oleh tipe bit komputer tersebut antara lain Float16, Float32 atau Float64. Jenis floating point juga dapat dipilih dengan menggunakan penulisan angka dengan notasi-e (sebagai contoh 2.3e-3 sebagai wakilan angka 0.0023) untuk Float64 dan notasi-f (sebagai contoh 2.3f-3 sebagai wakilan angka 0.0023) untuk Float32.\n\nBeberapa nilai khusus dalam floating point, dan tidak ada dalam bilangan bulat, yang memiliki peran penting dalam komputasi antara lain:\n\nNilai eps yang mewakili ketelitian bagi mesin (komputer), yaitu nilai yang menjadi pembeda antara satu floating point dengan floating point terdekatnya.\n\nNilai -Inf dan Inf yang mewakili nilai tak hingga bagi mesin (komputer), yaitu nilai yang terkait dengan nilai maksimum atau yang lebih besar serta nilai minimum yang lebih kecil bagi floating point.\n\nNilai NaN yang mewakili keadaan suatu error dalam proses komputasi, yaitu suatu nilai yang bukan nilai-nilai dalam floating point.\n\nxf = 2.3e-34\n\n\n\ntypeof(xf)\n\n\n\nyf = 23f-34\n\n\n\ntypeof(yf)\n\n\n\neps(1.0)\n\n\n\n(typemax(Float64), typemin(Float64))\n\n\n\n3.0 / Inf\n\n\n\n3.0 / 0\n\n\n\nsin(0) / 0\n\n\n\n","type":"content","url":"/materi/pengantar-julia#pecahan-floating-point","position":13},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Bilangan Kompleks dan Bilangan Rasional","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"type":"lvl3","url":"/materi/pengantar-julia#bilangan-kompleks-dan-bilangan-rasional","position":14},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Bilangan Kompleks dan Bilangan Rasional","lvl2":"Bilangan Bulat dan Pecahan (Floating Point)"},"content":"Dalam berbagai permasalahan, proses komputasi sering melibatkan bilangan kompleks dan bilangan rasional. Dalam Julia, tetapan im digunakan untuk mewakili bilangan imajiner i=\\sqrt{-1}. Berbeda dengan kebanyakan bahasa pemrograman yang menggunakan tetapan i atau j untuk mewakili bilangan imajiner, dalam Julia digunakan tetapan im karena notasi i atau j sering dimanfaatkan sebagai indeks dalam proses perhitungan perulangan (looping). Penulisan bilangan kompleks dalam Julia mengikuti penulisan matematika baku sebagai contoh z = 3 + 2im, yang lebih ringkas dibanding penulisan z = 3 + 2*im.\n\nJulia memiliki cara alamiah untuk mewakili bilangan rasional, yaitu bilangan yang dapat dinyatakan sebagai pembagian dari 2 bilangan bulat, dalam bentuk //.  Penggunaan bilangan rasional dalam proses komputasi sangat berguna dalam berbagai bidang permasalahan.\n\n","type":"content","url":"/materi/pengantar-julia#bilangan-kompleks-dan-bilangan-rasional","position":15},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Operasi Matematika dan Fungsi Dasar"},"type":"lvl2","url":"/materi/pengantar-julia#operasi-matematika-dan-fungsi-dasar","position":16},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Operasi Matematika dan Fungsi Dasar"},"content":"Beberapa perintah untuk melakukan operasi matematika beserta beberapa fungsi dasar dalam Julia memiliki ungkapan yang secara alamiah sama dengan penulisan baku dalam matematika. Tidak seperti perintah dalam bahasa lain, sebagai contoh dalam Julia dibolehkan untuk menulis perintah dalam bentuk 2x, alih-alih dalam bentuk 2 * x. Beberapa ungkapan operasi matematika beserta fungsi dasar yang lebih lengkap dapat merujuk pada \n\nDokumen Julia.\n\nx = 2.6 + 2.1im # sama dengan penulisan 2.6 + 2.1*im\n\n\n\ny = 3\n\n\n\nx * y\n\n\n\nx / y\n\n\n\nx + y\n\n\n\nx - y\n\n\n\ny ^ 3\n\n\n\ny % 2 # sisa dari pembagian x terhadap y\n\n\n\n2x # sama seperti menulis y = 2 * x\n\n\n\ny + 1//2\n\n\n\nnilai = cos(y)\n\n\n\n","type":"content","url":"/materi/pengantar-julia#operasi-matematika-dan-fungsi-dasar","position":17},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Boolean dan Perbandingan Numerik","lvl2":"Operasi Matematika dan Fungsi Dasar"},"type":"lvl3","url":"/materi/pengantar-julia#operasi-boolean-dan-perbandingan-numerik","position":18},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Boolean dan Perbandingan Numerik","lvl2":"Operasi Matematika dan Fungsi Dasar"},"content":"Dalam beberapa proses komputasi kadang diperlukan untuk memilih berdasar beberapa kondisi atau persyaratan melalui operasi Boolean, yaitu operasi untuk melihat suatu keadaan adalah benar (true) atau salah (false) serta perbandingan 2 nilai secara numerik. Beberapa operasi Boolean serta perbandingan numerik yang difasilitasi dalam Julia diberikan dalam contoh berikut.\n\nkondisi1 = 2.5 == 3.7 # operasi kesamaan \n\n\n\nkondisi2 = 2.5 != 3.7 # operasi ketidaksamaan\n\n\n\n2.5 < 3.7 # operasi kurang dari\n\n\n\n2.5 <= 3.7 # operasi kuranf dari atau sama dengan\n\n\n\n2.5 >= 3.7 # operasi lebih dari atau sama dengan\n\n\n\n!kondisi1 # operasi boolean NEGATION yaitu kebalikan dari keadaan sebelumnya\n\n\n\nkondisi1 && kondisi2 # operasi boolean AND yaitu false jika salah satu false\n\n\n\nkondisi1 || kondisi2 # operasi boolean OR yaitu true jika salah satu true\n\n\n\n","type":"content","url":"/materi/pengantar-julia#operasi-boolean-dan-perbandingan-numerik","position":19},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Pembaruan (updating)","lvl2":"Operasi Matematika dan Fungsi Dasar"},"type":"lvl3","url":"/materi/pengantar-julia#operasi-pembaruan-updating","position":20},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Pembaruan (updating)","lvl2":"Operasi Matematika dan Fungsi Dasar"},"content":"Dalam beberapa proses komputasi, kadang diperlukan pembaruan suatu nilai oleh operasi matematika tertentu. Sebagai gambaran, untuk memperbarui nilai suatu variable agar nilai tersebut bertambah 3 maka Julia memberikan operasi ringkas dalam bentuk x += 3, yang sama dengan operasi x = x + 3. Operasi tersebut juga berlaku untuk bentuk lain yaitu -=, *=, /=, ^=, %= dan lainnya.\n\nx = 5.6\n\n\n\nx += 3 \n\n\n\ny = 2\n\n\n\ny ^= 3 # sama dengan operasi y = y^3\n\n\n\n","type":"content","url":"/materi/pengantar-julia#operasi-pembaruan-updating","position":21},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Array"},"type":"lvl2","url":"/materi/pengantar-julia#array","position":22},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Array"},"content":"Array merupakan jenis variable berupa jajaran dari nilai-nilai yang disajikan dalam bentuk 1, 2 hingga multi-dimensi. Array dalam 1 dimensi digunakan untuk melambangkan suatu vektor yang memiliki bentuk berupa jajaran nilai pada beberapa baris dalam satu kolom (biasa disebut sebagai matrik kolom). Array dalam 2 dimensi digunakan untuk melambangkan suatu matrik yang memiliki bentuk berupa jajaran nilai pada beberapa baris dan kolom. Secara umum array dalam 3 dimensi atau multi-dimensi biasa digunakan untuk melambangkan suatu tensor.\n\nArray memegang peran penting dalam komputasi karena operasi yang melibatkan banyak nilai, yang berarti banyak variable, akan dapat diwakili oleh satu variable sehingga menyederhanakan prosedur penyelesaian. Implementasi array dalam Julia cukup lengkap yang dapat dirujuk pada \n\nDokumentasi Array. Berikut disajikan beberapa hal penting dari implementasi array tersebut.","type":"content","url":"/materi/pengantar-julia#array","position":23},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Beberapa Fungsi Dasar","lvl2":"Array"},"type":"lvl3","url":"/materi/pengantar-julia#beberapa-fungsi-dasar","position":24},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Beberapa Fungsi Dasar","lvl2":"Array"},"content":"Array diwakili oleh lambang kurung persegi [ ], ketika berupa vektor maka dapat dibangkitkan dengan sintak [x1, x2, ...], dengan x1, x2, ... merupakan unsur-unsur vektor.\n\nArray berupa matrik dapat dibangkitkan dengan sintak [x1 x2 ...; y1 y2 ...; ...], yaitu memberikan jarak spasi antar unsur matrix pada suatu baris dan pemberian semicolon untuk memisahkan kolom.\n\nDalam beberapa permasalahan komputasi, kadang diperlukan array dengan bentuk khusus sebagai contoh matrik yang memiliki semua unsur bernilai 1. Beberapa fungsi dasar untuk membangkitkan array dalam bentuk khusus tersebut diberikan pada contoh berikut.\n\nA = [1,2,3]\n\n\n\nB = [1 2 3;3 4 5; 6 7 8]\n\n\n\nC = zeros(2,3) # matrik orde 2x3 (2 baris dan 3 kolom) dengan semua unsur bernilai 0\n\n\n\nD = ones(3,4) # matrik orde 3x4 dengan semua unsur bernilai 1\n\n\n\nE = rand(3,2) # matrik orde 3x2 dengan semua unsur bernilai bilangan random dalam interval 0 dan 1\n\n\n\nlength(E) # operasi untuk menunjukkan cacah unsur pada matrik E\n\n\n\nsize(E) # operasi untuk menunjukkan daftar urutan (*tuple*) dimensi atau orde bagi matrik E\n\n\n\nndims(E) # operasi untuk menunjukkan dimensi bagi matrik E\n\n\n\n","type":"content","url":"/materi/pengantar-julia#beberapa-fungsi-dasar","position":25},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Indeks dalam Array","lvl2":"Array"},"type":"lvl3","url":"/materi/pengantar-julia#indeks-dalam-array","position":26},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Indeks dalam Array","lvl2":"Array"},"content":"Berbeda dengan bahasa pemrogram lain, sebagai contoh Python, aturan penomoran atau indeks dalam suatu array dimulai dengan indeks 1 (bukan 0). Kemudian urutan indeks dalam seluruh array didasarkan pada urutan kolom (bukan baris). Contoh berikut adalah perintah untuk menampilkan unsur dari suatu array (vektor atau matrik) berdasar aturan indeks tersebut.\n\nPenomoran atau pengaturan indeks dari suatu unsur tertentu dalam suatu array dalam dilakukan dengan 2 cara:\n\nCartesian Index yaitu penomoran dengan mengikuti indeks bagi array tersebut, sebagai contoh unsur A[2.3] adalah unsur beris ke 2 dan kolom ke 3 dari matrik A.\n\nLinear Index yaitu penomoran dengan mengikuti urutan lokasi suatu unsur tertentu bagi arrtay tersebut, sesuai urutan kolom.\n\nPerintah CartesianIndices dan LinearIndices digunakan untuk melakukan konversi dari masing-masing cara penomoran tersebut.\n\nA = [1,2,3,4,5]\n\n\n\nA[5] # mencuplik nilai dari unsur ke 5 bagi vektor A\n\n\n\nB = [1 2 3;3 4 5; 6 7 8]\n\n\n\nB[5] # mencuplik nilai dari unsur ke 5 bagi matrik B, yaitu dimulai dari kolom ke 1 (terdiri atas 3 unsur) dan dilanjutkan ke kolom ke 2\n\n\n\nB[2,2] # mencuplik nilai dari unsur baris ke 2 dan kolom ke 2, yang sama dengan perintah B[5] \n\n\n\nCartesianIndices(B)[5] # mengubah dari unsur urutan ke 5 menjadi unsur baris ke 2 dan kolom ke 2\n\n\n\nLinearIndices(B)[2,2] # mengubah dari unsur baris ke 2 dan kolom ke 2 menjadi unsur urutan ke 5\n\n\n\n","type":"content","url":"/materi/pengantar-julia#indeks-dalam-array","position":27},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Vektorisasi pada Array","lvl2":"Array"},"type":"lvl3","url":"/materi/pengantar-julia#operasi-vektorisasi-pada-array","position":28},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Vektorisasi pada Array","lvl2":"Array"},"content":"Operasi vektorisasi merupakan operasi matematika yang bekerja pada seluruh unsur pada array secara bersamaan, bukan satu persatu pada tiap unsur array. Mekanisme operasi matematika pada seluruh unsur yang semacam ini sehingga operasi vektorisasi kadang disebut pemrosesn berbasis unsur (element-wise processing). Fitur operasi vektorisasi dalam Julia bukan hanya menyederhanakan proses komputasi namun secara umum dapat mempercepat proses komputasi, khususnya pada komputer yang memfasilitasi pemrosesan paralel.\n\nJulia mengimplementasikan operasi vektorisasi berupa penambahan perintah dot (yaitu .) di depan operasi matematika tertentu. Sebagai contoh, untuk mengalikan suatu nilai yang diwakili oleh variable x1 dengan nilai x2 maka digunakan sintak x1 * x2. Adapun untuk mengalikan suatu nilai yang diwakili oleh variable x1 dengan seluruh nilai pada suatu array yang diwakili oleh variable X2 maka diganakan sintak x1 .* X2.\n\nx1 = 2.0\n\n\n\nx2 = 0.4\n\n\n\nX2 = rand(2,2)\n\n\n\nx1 * x2\n\n\n\nx1 .* X2\n\n\n\nImplementasi element-wise memerlukan kehati-hatian ketika melibatkan matrik agar tidak rancu dengan operasi matrik sejenis yang secara definisi boleh jadi berbeda. Sebagai contoh, operasi perkalian matrik A dengan matrik B, yaitu A * B, secara definisi dilakukan dengan mengalikan baris matrik A dengan kolom matrik B. Oleh karena itu persyaratan agar A * B berlaku adalah jumlah kolom matrik A perlu sama dengan jumlah baris matrik B. Sedangkan operasi perkalian element-wise   matrik A dengan matrik B, yaitu A .* B, secara definisi dilakukan dengan mengalikan setiap unsur matrik A dengan setiap unsur matrik Bpada indeks matrik yang sama. Dengan demikian tidak ada persyaratan bahwa jumlah kolom matrik A perlu sama dengan jumlah baris matrik Bagar A .* B berlaku. Contoh berikut memberikan gambaran jelas terkait uraian tersebut.\n\nA = rand(2,2)\n\n\n\nB = rand(2,2)\n\n\n\nC = A * B\n\n\n\nD = A .* B\n\n\n\nC == D\n\n\n\n","type":"content","url":"/materi/pengantar-julia#operasi-vektorisasi-pada-array","position":29},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Broadcasting","lvl2":"Array"},"type":"lvl3","url":"/materi/pengantar-julia#operasi-broadcasting","position":30},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl3":"Operasi Broadcasting","lvl2":"Array"},"content":"Persyaratan agar operasi vektorisasi berbasis element-wise berlaku adalah adanya kesamaan orde bagi array yang terlibat dalam operasi. Apabila array yang terlibat ternyata tidak memiliki orde yang sama maka proses element-wise diimplemnetasikan melalui operasi broadcasting dengan sintak braodcast(+,A,B) untuk operasi broadcasting penjumlahan. Operasi broadcasting yang lain maka dilakukan dengan mengganti opearasi + dengan operasi matematika yang berpadanan.\n\nA = rand(2,2)\n\n\n\nB = rand(1,2)\n\n\n\nC = broadcast(+,A,B)\n\n\n\n","type":"content","url":"/materi/pengantar-julia#operasi-broadcasting","position":31},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Blok atau Gabungan Perintah"},"type":"lvl2","url":"/materi/pengantar-julia#blok-atau-gabungan-perintah","position":32},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Blok atau Gabungan Perintah"},"content":"Suatu blok atau gabungan beberapa perintah kadang perlu diproses agar beberapa hasil yang diperoses tersebut akan dapat digunakan untuk menghasilkan satu hasil akhir. Blok atau gabungan beberapa perintah tersebut dalam Julia dapat dimplementasikan dalam berbagai bentuk, seperti bentuk fungsi, proses conditional atau proses looping,  yang memiliki penanda pada akhir blok berupa perintah end. Gabungan perintah dalam Julia juga dapat diimplementasikan dalam bentuk umum berupa penanda perintah begin dan end seperti contoh berikut.\n\nfor i = 1:5\n    i = i^3\n    println(i)\nend\n\n\n\nnilai =\nbegin\n    x = 3.2\n    y = 5.6\n    x/y\nend\n\n\n\nnilai\n\n\n\n","type":"content","url":"/materi/pengantar-julia#blok-atau-gabungan-perintah","position":33},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Fungsi dalam Julia"},"type":"lvl2","url":"/materi/pengantar-julia#fungsi-dalam-julia","position":34},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Fungsi dalam Julia"},"content":"Kebanyakan fungsi dasar yang biasa digunakan di matematika, sebagai contoh fungsi trigonometri, telah terdefinisi dalam Julia sehingga dapat langsung diimplementasikan dalam proses komputasi. Apabila diperlukan bentuk fungsi yang belum termasuk dalam fungsi bawaan Julia, maka fungsi tersebut perlu didefinisikan terlebih dahulu sebelum dapat dimanfaatkan.\n\nSecara umum bentuk fungsi dalam Julia akan berupa suatu obyek yang memetakan seperangkat argumen bagi fungsi, untuk menghasilkan satu atau beberapa nilai bagi fungsi tersebut. Beberapa contoh berikut merupakan metode yang dapat dipilih untuk mendefinisikan suatu fungsi. Uraian lebih lengkap terkait fungsi dapat merujuk pada \n\nDokumen Fungsi.\n\nfunction f(x,y)  # mendefinisikan fungsi untuk perkalian variable x dan y\n    x * y\nend\n\n\n\nf(2,4)\n\n\n\nf(x,y) = x * y # cara lain mendefinisikan fungsi untuk perkalian variable x dan y\n\n\n\nf(3,4)\n\n\n\n","type":"content","url":"/materi/pengantar-julia#fungsi-dalam-julia","position":35},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Proses Bersyarat (Conditional)"},"type":"lvl2","url":"/materi/pengantar-julia#proses-bersyarat-conditional","position":36},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Proses Bersyarat (Conditional)"},"content":"Dalam proses komputasi, suatu evaluasi tertentu kadang perlu dilakukan ketika satu persyaratan dipenuhi dan sebaliknya, suatu evaluasi tersebut tidak perlu dilakukan ketika persyaratan tersebut tidak terpenuhi. Proses bersyarat seperti hal tersebut dapat diimplementasikan melalui sintak if-elseif-else seperti contoh berikut.\n\nfunction hasil(x,y)\n    if (x < y)\n        x + y\n    elseif (x > y)\n        x - y\n    else\n        x * y\n    end\nend\n        \n\n\n\nhasil(3,5)\n\n\n\nhasil(5,2)\n\n\n\nhasil(5,5)\n\n\n\n","type":"content","url":"/materi/pengantar-julia#proses-bersyarat-conditional","position":37},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Proses Berulang (Looping)"},"type":"lvl2","url":"/materi/pengantar-julia#proses-berulang-looping","position":38},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Proses Berulang (Looping)"},"content":"Ketika suatu proses perlu dilakukan secara berulang maka perintah untuk proses tersebut akan menjadi panjang dan oleh karena itu diperlukan mekanisme untuk meringkas perintah dalam bentuk proses berulang (looping). Proses looping dapat diwujudkan dalam dua sintak yaitu while-enddan for-end seperti contoh berikut.\n\nfunction total(i)\n    i = 1\n    while (i < 10)\n        i += 2\n        println(i)\n    end\nend\n\n\n\ntotal(9)\n\n\n\nfunction total(n)\n    for i = 1:n\n        j = i + 2\n        println(j)\n    end\nend\n\n\n\ntotal(9)\n\n\n\nDalam ungkapan di atas, notasi colon yaitu : pada sintak i = 1:n mamiliki arti bahwa variable i akan bernilai dari 1 hingga nilai n.\n\n","type":"content","url":"/materi/pengantar-julia#proses-berulang-looping","position":39},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Penggunaan Modul Tambahan"},"type":"lvl2","url":"/materi/pengantar-julia#penggunaan-modul-tambahan","position":40},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Penggunaan Modul Tambahan"},"content":"Dalam beberapa keperluan, kadang diperlukan suatu operasi tertentu yang tidak termasuk dalam paket (library) bawaan Julia. Sebagai contoh, keperluan penggunaan matrik Identitas I yang sering muncul dalam berbagai perhitungan aljabar linear ternyata tidak termasuk dalam library bawaan. Untuk keadaan seperti hal tersebut maka diperlukan pemanggilan library tambahan dengan menggunakan sintak using. Di dalam \n\nPanduan Julia akan dapat ditemukan bahwa matrik Identitas I termuat dalam library yang disebut LinearAlgebra. Contoh berikut menunjukkan cara untuk memuat library tambahan menggunakan perintak using.\n\nusing LinearAlgebra\n\n\n\nA = rand(2,2)\n\n\n\nB = I * A\n\n\n\n","type":"content","url":"/materi/pengantar-julia#penggunaan-modul-tambahan","position":41},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Plot: Visualisasi Data"},"type":"lvl2","url":"/materi/pengantar-julia#plot-visualisasi-data","position":42},{"hierarchy":{"lvl1":"Tinjauan Ringkas Bahasa Julia","lvl2":"Plot: Visualisasi Data"},"content":"Hasil dari proses komputasi pada umumnya melibatkan banyak data dan memerlukan penanganan lebih lanjut terhadap data tersebut. Salah satu cara untuk penanganan data adalah dengan melakukan visualisasi berupa plot terhadap data tersebut. Julia memeiliki fasilitas ynag cukup lengkap untuk membangkitkan berbagai jenis plot sesuai karakteristik data. Berbagai implementasi perintah plot di dalam Julia dapat merujuk pada \n\nDokumen Plot.\n\nSintak untuk membangkitkan plot adalah dengan memuat library yaitu using Plots dan dikuti dengan beberapa perintah tertentu. Berikut merupakan beberapa contoh berdasar dokumen tersebut.\n\nusing Plots\n\n\n\nx = -pi:0.1:pi\n\n\n\ny = sin.(x);\n\n\n\nplot(x,y)\n\n","type":"content","url":"/materi/pengantar-julia#plot-visualisasi-data","position":43},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul"},"type":"lvl1","url":"/materi/period-of-pendulum-by-proper-integration-julia","position":0},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul"},"content":"","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia","position":1},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Implementasi Integrasi Numerik"},"type":"lvl2","url":"/materi/period-of-pendulum-by-proper-integration-julia#implementasi-integrasi-numerik","position":2},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Implementasi Integrasi Numerik"},"content":"Persamaan gerak benda bermassa m yang digantungkan pada seutas tali dengan panjang l dan massa diabaikan, di bawah pengaruh medan gravitasi bumi g, adalahm\\frac{d^2 x(t)}{dt^2}=-mg\\sin\\theta(t)\n\nDalam radian, mengingat x(t)=l\\theta(t) dengan \\theta(t) adalah sudut simpangan benda terhadap titik setimbang, maka persamaan gerak tersebut dapat dinyatakan dalam bentuk persamaan diferensial orde dua berikut\\frac{d^2\\theta(t)}{dt^2}=-\\frac{g}{l}\\sin\\theta(t)\n\nPenyelesaian persamaan diferensial tersebut secara analitik akan cukup sulit karena berbentuk nonlinear dalam \\theta(t). Untuk keadaan khusus, pada simpangan kecil sedemikian hingga \\sin\\theta(t)\\approx \\theta(t) maka pers (1) di atas dapat didekati oleh bentuk\\frac{d^2\\theta(t)}{dt^2}\\approx-\\frac{g}{l}\\theta(t)=-\\omega^2\\theta(t)\n\ndengan\\omega=\\frac{2\\pi}{T}=\\sqrt{\\frac{g}{l}}\n\nDengan demikian ungkapan periode bandul pada simpangan kecil, yang dinotasikan sebagai T_0 berbentukT_0=2\\pi\\sqrt{\\frac{l}{g}}\n\nPada simpangan kecil ini, umumnya terpenuhi saat simpangan \\theta<10^\\circ, maka penyelesaian pers (2) berbentuk\\theta(t)=\\theta_0\\cos(\\omega t)\n\nUngkapan tersebut diperoleh dengan asumsi syarat awal bahwa pada saat awal t=0 maka benda berada pada simpangan maksimum di \\theta=\\theta_0 dan kecepatan awal \\left[\\frac{d\\theta}{dt}\\right]_{t=0}=0.\n\nUntuk sebarang simpangan, yang tidak dibatasi pada simpangan kecil, penyelesaian pers (1) menjadi sulit untuk diperoleh secara analitik sehingga bentuk kompak penyelesaian simpangan seperti diberikan oleh pers (3) menjadi tidak berlaku. Oleh karena itu periode bandul pada sebarang simpangan (T) tidak dapat diperoleh berdasar pers (2c).","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia#implementasi-integrasi-numerik","position":3},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Periode Bandul pada Sebarang Simpangan (T)"},"type":"lvl2","url":"/materi/period-of-pendulum-by-proper-integration-julia#periode-bandul-pada-sebarang-simpangan-t","position":4},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Periode Bandul pada Sebarang Simpangan (T)"},"content":"Perhitungan periode bandul pada sebarang simpangan (T) dapat diperoleh dengan meninjau persamaan gerak bandul pada bentuk umum seperti disajikan oleh pers (1). Dengan mengalikan kedua ruas pada pers (1) di atas dengan \\frac{d\\theta}{dt} dan kemudian melakukan intergrasi terhadap dt maka diperoleh ungkapan\\frac{d\\theta}{dt}=\\sqrt{\\frac{2g}{l}}\\sqrt{\\cos\\theta - \\cos\\theta_0}\n\nBerdasar syarat awal tersebut, persamaan diferensial di atas dapat dinyatakan dalam ungkapan integral dalam bentukt=\\sqrt{\\frac{l}{2g}}\\int_{\\theta_0}^\\theta\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}\n\nPeriode T dapat dipahami sebagai waktu yang ditempuh bagi benda untuk bergerak dari posisi \\theta_0 dan berayun kembali ke posisi semula \\theta_0. Dengan pengertian lain, periode T adalah empat kali waktu yang diperlukan untuk bergerak dari \\theta=\\theta_0 menuju \\theta=0. Berdasar pers(4) maka ungkapan bagi perhitungan periode T dapat dinyatakan dalam bentuk integral dalam bentukT=4\\,\\sqrt{\\frac{l}{2g}}\\int_0^{\\theta_0}\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}\n\nUngkapan integral tersebut berbentuk integral tak layak (improper integral) akibat terjadinya singularitas (bernilai tak hingga) pada nilai integral di bagian batas atas integral, yaitu saat \\theta=\\theta_0. Perhitungan bagi nilai periode T akibatnya menjadi sulit.\n\nUntuk mengatasi kesulitan ini maka bentuk integral tak layak (improper integral) di atas perlu diubah menjadi integral layak (proper integral). Didefinisikan peubah baru \\xi(t), yang dikaitkan oleh \\theta(t) melalui kaitan\\sin\\xi(t)=\\frac{\\sin\\frac{\\theta(t)}{2}}{\\sin\\frac{\\theta_0}{2}}\n\nDalam peubah \\xi(t) maka ungkapan integral tak layak bagi periode T akan berubah menjadi integral layak dalam bentukT=4\\,\\sqrt{\\frac{l}{g}}\\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}\n\ndengank=\\sin\\frac{\\theta_0}{2}\n\nDengan demikian, ungkapan bentuk integral layak di atas dapat digunakan sebagai salah satu metode untuk memperoleh nilai periode bandul pada sebarang simpangan T.","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia#periode-bandul-pada-sebarang-simpangan-t","position":5},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Pemanfaatan Besaran Fisis Tak Berdimensi"},"type":"lvl2","url":"/materi/period-of-pendulum-by-proper-integration-julia#pemanfaatan-besaran-fisis-tak-berdimensi","position":6},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Pemanfaatan Besaran Fisis Tak Berdimensi"},"content":"Meskipun ungkapan dalam pers (7) dapat digunakan untuk pencarian periode T berdasarkan perhitungan nilai integral, namun dari pertimbangan komputasi akan lebih menguntungkan apabila dapat diubah ke bentuk yang tidak melibatkan satuan dari besaran fisis yang terlibat. Dengan kata lain, bentuk tersebut perlu diubah ke dalam bentuk yang melibatkan besaran fisis yang tak berdimensi. Ada berbagai cara untuk mendapatkan bentuk tak berdimensi bagi ungkapan pers (7).\n\nSalah satu cara untuk mendapatkan ungkapan periode bandul yang tidak melibatkan besaran fisis adalah dengan membagi ungkapan periode bandul T dalam pers (7) dengan ungkapan periode bandul pada simpangan kecil T_0 dalam pers (2c) dan menyebut sebagai periode bandul ternormalisir pada sebarang simpangan (\\tau) dalam bentuk\\tau=\\frac{T}{T_0}=\\frac{4\\,\\sqrt{\\frac{l}{g}}\\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}}{2\\pi\\sqrt{\\frac{l}{g}}}=\\frac{2}{\\pi}\\,\\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}\n\nMelakukan komputasi yang melibatkan besaran fisis tak berdimensi pada umumnya lebih menguntungkan karena nilai dari besaran yang terlibat berada pada rentang nilai yang lebih terukur, umumnya antara nilai 0 dan 1, sehingga kadang disebut sebagai satuan yang ternormalisir.","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia#pemanfaatan-besaran-fisis-tak-berdimensi","position":7},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Integrasi Numerik: Metode Simpson"},"type":"lvl2","url":"/materi/period-of-pendulum-by-proper-integration-julia#integrasi-numerik-metode-simpson","position":8},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Integrasi Numerik: Metode Simpson"},"content":"Berdasarkan pada prosedur yang telah diuraikan di atas, perhitungan nilai integral dapat dilakukan secara numerik dengan beberapa metode pendekatan perhitungan nilai integral, seperti metode Trapesium atau metode Simpson. Untuk pilihan metode Simpson, maka proses integrasi numerik bagi sebarang fungsi f(x) akan memanfaatkan pendekatan deret fungsi di sekitar titik x=x_1 hingga orde 2 (kuadratis) dalam bentukf(x)\\approx  f(x_1)+\\frac{(x-x_1)}{1!}\\left.\\frac{df(x)}{dx}\\right]_{x=x_1}+\\frac{(x-x_1)^2}{2!}\\left.\\frac{d^2f(x)}{dx^2}\\right]_{x=x_1}\n\nBerdasar ungkapan pendekatan deret tersebut maka diperolehf(x_1+h)\\approx  f(x_1)+\\frac{h}{1!}\\left.\\frac{df(x)}{dx}\\right]_{x=x_1}+\\frac{h^2}{2!}\\left.\\frac{d^2f(x)}{dx^2}\\right]_{x=x_1}f(x_1-h)\\approx  f(x_1)-\\frac{h}{1!}\\left.\\frac{df(x)}{dx}\\right]_{x=x_1}+\\frac{h^2}{2!}\\left.\\frac{d^2f(x)}{dx^2}\\right]_{x=x_1}\n\nApabila pers (11b) dikurangkan atau ditambahkan terhadap pers (11a) maka mudah ditunjukkan bahwa ungkapan berikut akan berlaku, yaitu\\left.\\frac{df(x)}{dx}\\right]_{x=x_1}\\approx \\frac{f(x_1+h)-f(x_1-h)}{2h}\\left.\\frac{d^2f(x)}{dx^2}\\right]_{x=x_1}\\approx \\frac{f(x_1+h)-2f(x_1)+f(x_1-h)}{h^2}\n\nBerdasar pers (12a) dan (12b) di atas maka pers (10) menjadi\\begin{align}\nf(x)\\approx  &f(x_1)+\\frac{(x-x_1)}{1!}\\left[\\frac{f(x_1+h)-f(x_1-h)}{2h}\\right]+\\nonumber\\\\\n&\\frac{(x-x_1)^2}{2!}\\left[\\frac{f(x_1+h)-2f(x_1)+f(x_1-h)}{h^2}\\right]\n\\end{align}\n\nMemanfaatkan pers (13) tersebut, tinjau masalah untuk menghitung pendekatan bagi nilai integral I dari sebarang fungsi f(x) dari batas integral x=x_1-h hingga x=x_1+h seperti berikut\\begin{align}\nI=&\\int_{x_1-h}^{x_1+h} f(x) dx\\approx\\int_{x_1-h}^{x_1+h}\\left\\{f(x_1)+\\frac{(x-x_1)}{1!}\\left[\\frac{f(x_1+h)-f(x_1-h)}{2h}\\right]+\\right.\\nonumber\\\\\n&\\left.\\frac{(x-x_1)^2}{2!}\\left[\\frac{f(x_1+h)-2f(x_1)+f(x_1-h)}{h^2}\\right]\\right\\}dx\n\\end{align}\n\nUntuk penyederhaan bentuk ungkapan dan nantinya berguna pada langkah komputasi maka dapat diperkenalkan beberapa notasi yaitu x_0=x_1-h atau x_1=x_0+h serta x_2=x_1+h. Dengan melakukan proses integrasi pada pers (14) maka diperoleh bentukI=\\int_{x_0}^{x_2} f(x) dx\\approx\\frac{h}{3}\\left[f(x_0)+4f(x_1)+f(x_2)\\right]\n\nSecara umum, untuk batas integral dari x=a hingga x=b maka pendekatan bagi nilai integral dapat dilakukan dengan melakukan proses diskretisasi bagi peubah x yaitu membagi rentang x=a hingga x=b menjadi N bagian dengan lebar h=\\tfrac{b-a}{N} yang kecil dan N adalah bilangan genap. Oleh karena itu dapat digunakan titik-titik diskret bagi x dalam ungkapanx_0=a;\\quad x_N=b; \\quad x_i=x_0+ih; \\quad i=1,2,3,\\cdots, N-1;\n\nDengan titit-titik diskret tersebut maka integrasi numerik I bagi sebarang fungsi f(x), disebut sebagai metode Simpson, dapat ditulis dalam bentuk\\begin{align}\nI&=\\int_a^b\\,f(x)dx=\\int_{x_0}^{x_2}\\,f(x)dx+\\int_{x_2}^{x_4}\\,f(x)dx+\\cdots+\\int_{x_{N-2}}^{x_N}\\,f(x)dx\\nonumber\\\\\n&\\approx\\frac{h}{3}\\left[f(x_0)+4f(x_1)+f(x_2)\\right]+\\cdots+\\frac{h}{3}\\left[f(x_{N-2})+4f(x_{N-1})+f(x_N)\\right]\\nonumber\\\\\n&\\approx\\frac{h}{3}\\left[f(x_0)+4f(x_1)+2f(x_2)+\\cdots+4f(x_{N-1})+f(x_N)\\right]\\nonumber\\\\\n&\\approx\\frac{h}{3}\\left[f(x_0)+f(x_N)+4\\sum_{i=1,3,\\cdots}^{N-1}f(x_i)+2\\sum_{i=2,4,\\cdots}^{N-2}f(x_i)\\right]\n\\end{align}","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia#integrasi-numerik-metode-simpson","position":9},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Algoritma Perhitungan Periode Bandul"},"type":"lvl2","url":"/materi/period-of-pendulum-by-proper-integration-julia#algoritma-perhitungan-periode-bandul","position":10},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Algoritma Perhitungan Periode Bandul"},"content":"Berawal dari keadaan diam di posisi simpangan maksimum tertentu \\theta_0, dan pada nilai l serta g tertentu, maka prosedur untuk memperoleh periode dalam satuan ternormalisir \\tau adalah seperti berikut\n\nBerikan nilai masukan \\theta_0, dan oleh karenanya hitung nilai k mellaui ungkapan pers (8)\n\nHitung nilai integral \\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}} berdasar ungkapan pers (10)\n\nNilai periode ternormalisir \\tau diperoleh melalui ungkapan pers (9)\n\nusing Plots\nusing SpecialFunctions\n\n\n\nfunction fung(x)\n    f = sin(x)\n    return f\nend\n\n\n\nfunction integsimpson(a, b, n)\n    h = (b - a) / n\n    sumodd = 0.0\n    nhalf = floor(Int, n / 2)\n    for i in 1:nhalf\n        xodd = a + (2 * i - 1) * h\n        sumodd += fung(xodd)\n    end\n    sumeven = 0.0\n    for i in 1:(nhalf - 1)\n        xeven = a + 2 * i * h\n        sumeven += fung(xeven)\n    end\n    integsimp = h * (fung(a) + 4.0 * sumodd + 2.0 * sumeven + fung(b)) / 3.0\n    return integsimp\nend\n\n\n\nintegsimpson(0,pi/3,100)\n\n\n\ncos(0)-cos(pi/3)\n\n\n\nfunction functional_bandul(k, a, b, n)\n    h = (b - a) / n\n    integ = 0.0\n    f = 1.0 / sqrt(1.0 - (k * sin(a))^2)\n    integ += h * f / 3.0\n    f = 1.0 / sqrt(1.0 - (k * sin(b))^2)\n    integ += h * f / 3.0\n    sumodd = 0.0\n    nhalf = floor(Int, n / 2)\n    for i in 1:nhalf\n        xodd = a + (2 * i - 1) * h\n        f = 1.0 / sqrt(1.0 - (k * sin(xodd))^2)\n        sumodd += f\n    end\n    sumeven = 0.0\n    for i in 1:(nhalf-1)\n        xeven = a + 2 * i * h\n        f = 1.0 / sqrt(1.0 - (k * sin(xeven))^2)\n        sumeven += f\n    end\n    integ += h * (4.0 * sumodd + 2.0 * sumeven) / 3.0\n    return integ\nend\n\n\n\na = 0.0\nb = pi / 2.0\ntheta0_val = pi / 200.0\nk_val = sin(theta0_val / 2.0)\nn_val = 100\ninteg = functional_bandul(k_val, a, b, n_val)\nperiode = 2.0 * integ / pi\nprintln(\"Periode: \", periode)\n\n\n\ntheta0 = range(pi / 200.0, stop=pi / 20.0, length=10)\ntau = zeros(10)\nn = 100\nfor i in 1:10\n    k = sin(theta0[i] / 2.0)\n    integ = functional_bandul(k, a, b, n)\n    tau[i] = 2.0 * integ / pi\nend\n\n\n\nplot(theta0, tau, xlabel=\"Simpangan Awal\", ylabel=\"Periode Ternormalisir\", title=\"Simpangan Awal vs Periode Ternormalisir\", legend=false)\n\n\n\n","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia#algoritma-perhitungan-periode-bandul","position":11},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Integral Elliptik (Elliptic Integral)"},"type":"lvl2","url":"/materi/period-of-pendulum-by-proper-integration-julia#integral-elliptik-elliptic-integral","position":12},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Integral Elliptik (Elliptic Integral)"},"content":"Ungkapan bentuk integral seperti diberikan oleh pers (7) atau pers (9) biasa disebut sebagai integral Elliptik lengkap jenis pertama (\n\nThe complete Elliptic Integral of the first kind) yang didefinisikan sebagai:K(k)=\\int_0^{\\tfrac{\\pi}{2}} \\frac{d\\theta}{\\sqrt{1-k^2\\sin^2\\theta}}\n\nDi dalam Julia, ungkapan tersebut difasilitasi package SpecialFunctionsoleh  fungsi khas dengan nama panggilan ellipk.\n\nUntuk membandingkan hasil dari penggunaan integrasi numerik menggunakan metode Simpson yang diuraikan di atas dengan modul bawaan Julia yang difasilitasi oleh ellipk dapat ditunjukkan oleh source-code berikut:\n\na = 0.0\nb = pi / 2.0\ntheta0 = pi / 200.0\nk = sin(theta0 / 2.0)\nn = 100\n\n\n\nhasil1 = functional_bandul(k, a, b, n)\ntau1 = 2.0 * hasil1 / pi\nprintln(\"Tau from Simpson method: \", tau1)\n\n\n\nm = k * k\nhasil2 = ellipk(m)\ntau2 = 2.0 * hasil2 / pi\nprintln(\"Tau from SpecialFunctions.ellipk: \", tau2)\n\n","type":"content","url":"/materi/period-of-pendulum-by-proper-integration-julia#integral-elliptik-elliptic-integral","position":13},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul"},"type":"lvl1","url":"/materi/period-of-pendulum-by-improper-integration-julia","position":0},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul"},"content":"","type":"content","url":"/materi/period-of-pendulum-by-improper-integration-julia","position":1},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Implementasi Kuadrature Numerik"},"type":"lvl2","url":"/materi/period-of-pendulum-by-improper-integration-julia#implementasi-kuadrature-numerik","position":2},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Implementasi Kuadrature Numerik"},"content":"Persamaan gerak benda bermassa m yang digantungkan pada seutas tali dengan panjang l dan massa diabaikan, di bawah pengaruh medan gravitasi bumi g, adalahm\\frac{d^2 x(t)}{dt^2}=-mg\\sin\\theta(t)\n\nDalam radian, mengingat x(t)=l\\theta(t) dengan \\theta(t) adalah sudut simpangan benda terhadap titik setimbang, maka persamaan gerak tersebut dapat dinyatakan dalam bentuk persamaan diferensial orde dua berikut\\frac{d^2\\theta(t)}{dt^2}=-\\frac{g}{l}\\sin\\theta(t)\n\nPerhitungan periode bandul pada sebarang simpangan (T) dapat diperoleh dengan meninjau persamaan gerak bandul pada bentuk umum seperti disajikan oleh pers (1). Dengan mengalikan kedua ruas pada pers (1) di atas dengan \\frac{d\\theta}{dt} dan kemudian melakukan intergrasi terhadap dt maka diperoleh ungkapan\\frac{d\\theta}{dt}=\\sqrt{\\frac{2g}{l}}\\sqrt{\\cos\\theta - \\cos\\theta_0}\n\nBerdasar syarat awal tersebut, persamaan diferensial di atas dapat dinyatakan dalam ungkapan integral dalam bentukt=\\sqrt{\\frac{l}{2g}}\\int_{\\theta_0}^\\theta\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}\n\nPeriode T dapat dipahami sebagai waktu yang ditempuh bagi benda bergerak dari posisi \\theta_0 dan berayun kembali ke posisi semula \\theta_0). Dengan pengertian lain, periode T adalah empat kali waktu yang diperlukan untuk bergerak dari \\theta=\\theta_0 menuju \\theta=0. Berdasar pers(4) maka ungkapan bagi perhitungan periode T dapat dinyatakan dalam bentuk integral dalam bentukT=4\\,\\sqrt{\\frac{l}{2g}}\\int_0^{\\theta_0}\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}\n\nDalam bentuk satuan universal, periode (\\tau) berbentuk\\tau=\\frac{T}{T_0}=\\frac{\\sqrt{2}}{\\pi}\\int_0^{\\theta_0}\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}\n\nUngkapan integral tersebut berbentuk integral tak layak (improper integral), yang salah satunya dicirikan oleh adanya singularitas (bernilai tak hingga) pada nilai integral di bagian batas atas integral, yaitu saat \\theta=\\theta_0. Perhitungan bagi nilai periode T akibatnya menjadi sulit apabila digunakan integrasi numerik dengan cara diskretisasi pada peubah bebas seperti yang dilakukan pada metode trapesium atau metode Simpson.","type":"content","url":"/materi/period-of-pendulum-by-improper-integration-julia#implementasi-kuadrature-numerik","position":3},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Metode Kuadratur Numerik: Gauss-Legendre"},"type":"lvl2","url":"/materi/period-of-pendulum-by-improper-integration-julia#metode-kuadratur-numerik-gauss-legendre","position":4},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Metode Kuadratur Numerik: Gauss-Legendre"},"content":"Perhitungan numerik bagi nilai integral yang selama ini telah dikaji, sebagai contoh metode Trapesium dan metode Simpson, adalah melalui proses diskretisasi peubah bebas pada titik-titik yang telah ditentukan x_0, x_1, \\cdots, x_N. Secara umum nilai integral dari batas a hingga b dapat didekati oleh bentuk umum\\int_{x_0}^{x_N}f(x)dx\\approx h\\sum_{i=0}^N c_i f(x_i)\n\ndengan h=x_i-x_{i-1} adalah ukuran langkah (step size) atau tingkat kehalusan diskretisasi, c_i adalah nilai koefisien atau bobot fungsi  yang seperangkat nilainya dapat ditentukan oleh metode diskretisasi yang dipilih dan x_0=a, x_N=b.\n\nSebagai contoh untuk metode Trapesium maka c_0=\\frac{1}{2}, c_N=\\frac{1}{2}, c_i=1 untuk i=1,2,\\cdots,N-1 sedangkan untuk metode Simpson maka c_0=\\frac{1}{3}, c_N=\\frac{1}{3}, c_{2i-1}=\\frac{4}{3} untuk i=1,2,\\cdots,\\frac{N}{2} dan c_{2i}=\\frac{2}{3} untuk i=1,2,\\cdots,\\frac{N}{2}-1.\n\nNampak dari metode perhitungan numerik pers (6) bahwa pendekatan perhitungan nilai integral akan tidak berhasil apabila terjadi singularitas pada nilai fungsi di titik tertentu, sebagai contoh pada titik \\theta_0 di bentuk integral tak layak pers (5) di atas.\n\nDengan prosedur yang agak berbeda, metode kuadratur numerik adalah metode untuk mendekati nilai integral berdasarkan seperangkat nilai bobot c_i dan titik x_i yang ditentukan berdasarkan tingkat (orde) ketelitian yang akan dicapai, bukan berdasarkan proses diskretisasi. Dengan tambahan derajat kebebasan untuk memilih seperangkat titik x_i maka 2 fitur yang dimiliki metode kuadratur, dibanding metode integrasi berdasar diskretisasi,  adalah\n\nSingularitas dapat dihindari karena seperangkat titik x_i tidak berada pada suatu titik yang menyebabkan nilai fungsi bernilai tak hingga.\n\nOrde ketelitian lebih tinggi karena jumlah peubah bebas menjadi lebih banyak.\n\nSebagai gambaran terkait 2 fitur tersebut, tinjau ungkapan kuadratur numerik untuk kasus sedehana, yaitu berdasar evaluasi pada 2 titik x_1 dan x_2 yang berada pada interval -1 dan 1, berikut\\int_{-1}^1 f(x)dx\\approx c_1 f(x_1) + c_2 f(x_2)\n\nDalam ungkapan tersebut, sejumlah 4 nilai c_1, c_2, x_1 dan x_2 menjadi bebas untuk ditentukan. Salah satu cara untuk menentukan 4 nilai tersebut adalah dengan menyusun 4 persamaan yang menjamin bahwa pers (7) akan memberikan nilai eksak apabila f(x) berbentuk polinomial hingga orde 3.\n\nUntuk f(x)=x^0=1 maka pers (7) menjadi\\int_{-1}^1 1dx=2= c_1 x_1^0 + c_2 x_2^0=w_1+w_2\n\nUntuk f(x)=x^1 maka pers (7) menjadi\\int_{-1}^1 xdx=0= c_1 x_1 + c_2 x_2\n\nUntuk f(x)=x^2 maka pers (7) menjadi\\int_{-1}^1 x^2dx=\\frac{2}{3}= c_1 x_1^2 + c_2 x_2^2\n\nUntuk f(x)=x^3 maka pers (7) menjadi\\int_{-1}^1 x^3dx=0= c_1 x_1^3 + c_2 x_2^3\n\nMudah ditunjukkan bahwa penyelsaian dari 4 persamaan serentak tersebut adalah\n\nc_1=1, c_2=1, x_1=-\\frac{1}{\\sqrt{3}}\\approx=-0.577350269 dan x_2=\\frac{1}{\\sqrt{3}}\\approx 0.577350269.\n\nDengan pers (7) dan 4 nilai yang diperoleh tersebut maka metode kuadratur numerik pada 2 titik  berbentuk\\int_{-1}^1 f(x)dx\\approx 1 f(-0.577350269) + 1 f(0.577350269)\n\nBerikut adalah contoh penggunaan kuadratur numerik 2 titik untuk menentukan nilai integral dari f(x)=2+x^2\n\nc1 = 1.0\nc2 = 1.0\nx1 = -0.577350269\nx2 = 0.577350269\nf1 = 2.0 + x1^2\nf2 = 2.0 + x2^2\nnilai_kuad = c1*f1 + c2*f2\nnilai_eksak = 2.0*(1.0 - (-1.0)) + (1.0^3 - (-1.0)^3)/3.0;\n\n\n\nnilai_kuad\n\n\n\nnilai_eksak\n\n\n\nBandingkan hasil kuadratur numerik 2 titik tersebut dengan intergrasi numerik 2 titik berdasar metode Trapesium untuk bentuk fungsi yang sama yaitu\n\nh = 1.0 - (-1.0)\nc1 = 0.5\nc2 = 0.5\nx1 = -1.0\nx2 = 1.0\nf1 = 2.0 + x1^2\nf2 = 2.0 + x2^2\nnilai_trap = (c1*f1 + c2*f2)*h;\n\n\n\nnilai_trap\n\n\n\nNampak bahwa perhitungan nilai integral berdasar metode kuadratur numerik nampak lebih teliti dibanding metode Trapesium untuk cacah titik yang sama. Ini merupakan salah satu fitur dari metode kuadratur numerik yang disinggung di atas.","type":"content","url":"/materi/period-of-pendulum-by-improper-integration-julia#metode-kuadratur-numerik-gauss-legendre","position":5},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl3":"Pengaturan Skala untuk Sebarang Batas Integral","lvl2":"Metode Kuadratur Numerik: Gauss-Legendre"},"type":"lvl3","url":"/materi/period-of-pendulum-by-improper-integration-julia#pengaturan-skala-untuk-sebarang-batas-integral","position":6},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl3":"Pengaturan Skala untuk Sebarang Batas Integral","lvl2":"Metode Kuadratur Numerik: Gauss-Legendre"},"content":"Apabila batas integral adalah dari y=a hingga y=b maka bentuk kuadratur numerik dalam pers (7) dari x=-1 hingga x=1 dapat dilakukan pengaturan skala secara linear dalam bentuky=\\frac{b-a}{2}x+\\frac{b+a}{2}\n\nDengan pengaturan skala tersebut maka bentuk kuadratur numerik dalam pers (7) dapat digunakan dalam bentuk menjadi\\int_a^b f(y)dy\\approx\\frac{b-a}{2}\\left[c_1 f\\left(\\frac{b-a}{2}x_1+\\frac{b+a}{2}\\right) + c_2 f\\left(\\frac{b-a}{2}x_2+\\frac{b+a}{2}\\right)\\right]\n\nDengan bentuk kuadratur numerik seperti disajikan oleh pers (13) maka ungkapan integral tak layak bagi periode bandul (\\tau) dalam pers (5a) akan dimungkinkan untuk dihitung karena nilai fungsi pada \\theta_0 tidak perlu untuk dihitung. Akibatnya proses perhitungan nilai integral pada titik singular dapat dihindari, yang merupakan salah satu fitur dari metode kuadratur numerik.\n\nusing LinearAlgebra\nusing SpecialFunctions\n\nfunction fung(y, y0)\n    return 1.0 / sqrt(cos(y) - cos(y0))\nend\n\nfunction kuad_GL(a, b)\n    n = 2\n    c = zeros(n)\n    x = zeros(n)\n    c[1] = 1.0\n    c[2] = 1.0\n    x[1] = -1.0/sqrt(3.0)\n    x[2] = 1.0/sqrt(3.0)\n    sum = 0.0\n    for i in 1:n\n        y = (b-a)*x[i]/2.0 + (b+a)/2.0\n        sum += c[i] * fung(y, b)\n    end\n    kuad = (b-a) * sum/2.0\n    return kuad\nend\n\ntheta0 = pi/200.0\na = 0.0\nb = theta0\nkuad = kuad_GL(a, b)\ntau = sqrt(2.0) * kuad / pi;\n\n\n\ntau\n\n\n\nNampak bahwa dengan menggunakan metode kuadratur numerik maka nilai periode bandul yang ternormalisir (\\tau) dapat diperoleh berdasar bentuk intergral tak layak, meskipun dengan nilai yang masih belum teliti. Hasil yang lebih teliti pada metode kuadratur numerik dapat diperoleh dengan mengambil cacah titik yang lebih banyak.\n\nSalah satu kendala bagi metode kuadratur numerik adalah perlunya pencarian seperangkat nilai c_i dan x_i, saat i=1,2,\\cdots, N, untuk cacah titik N yang dipilih. Pada umumnya, pencarian nilai-nilai c_i dan x_i tersebut dapat dilakukan dengan melibatkan operasi pada fungsi khas (special function) berupa polinomial orthonormal  tertentu.\n\nSebagai contoh, metode kuadratur numerik dengan ungkapan seperti diberikan oleh pers (7) merupakan bentuk khusus, yaitu saat cacah titik N=2, dari apa yang disebut sebagai metode kuadratur Gauss-Legendre dengan bentuk umum\\int_{-1}^1 f(x)dx\\approx \\sum_{i=1}^n c_i f(x_i)\n\nNilai-nilai x_i dapat diperoleh melalui akar-akar atau titik nol (zeros) dari polinomial Legendre orde ke n, dengan lambang P_n(x), sedangkan nilai-nilai c_i diperoleh dengan melibatkan turunan ke 1 dari polinomial tersebut, yaitu melalui ungkapanP_n(x_i)=0;\\qquad c_i=\\frac{2}{(1-x_i^2)\\left[P_n^{'}(x_i)\\right]^2}\n\nUntuk beberapa titik yang tidak terlalu banyak, nilai-nilai c_i dan x_i bagi kuadratur Gauss-Legendre, seperti diberikan oleh pers (16), diberikan dalam bentuk Tabel seperti berikut (\n\nGaussian Kuadrature)\n\nCacah titik n\n\nBobot c_i\n\nTitik x_i\n\n1\n\n2\n\n0\n\n2\n\n1\n\n-0.577350...\n\n1\n\n0.577350...\n\n\n\n3\n\n0.555556...\n\n-0.774597...\n\n0.888889...\n\n0\n\n\n\n0.555556...\n\n0.774597...\n\n\n\n4\n\n0.347855...\n\n-0.861136...\n\n0.652145...\n\n-0.339981...\n\n\n\n0.652145...\n\n0.339981...\n\n\n\n0.347855...\n\n0.861136...\n\n\n\n5\n\n0.236927...\n\n-0.90618...\n\n0.478629...\n\n-0.53846...\n\n\n\n0.568889...\n\n0\n\n\n\n0.478629...\n\n0.53846...\n\n\n\n0.236927...\n\n0.90618...\n\n\n\nUntuk memberikan gambaran bahwa pengambilan cacah titik yang semakin banyak maka akan dapat meningkatkan ketelitian metode kuadrature Gauss-Legendre, berikut akan diambil untuk n=5.\n\nfunction fung(y, y0)\n    return 1.0 / sqrt(cos(y) - cos(y0))\nend\n\nfunction kuad_GL1(a, b)\n  n = 5\n  c = zeros(n)\n  x = zeros(n)\n  c[1] = 0.236927\n  c[2] = 0.478629\n  c[3] = 0.568889\n  c[4] = 0.478629\n  c[5] = 0.236927\n  x[1] = -0.90618\n  x[2] = -0.53846\n  x[3] = 0.0\n  x[4] = 0.53846\n  x[5] = 0.90618\n  sum = 0.0\n  for i in 1:n\n    y = (b-a)*x[i]/2.0 + (b+a)/2.0\n    sum += c[i] * fung(y, b)\n  end\n  kuad = (b-a) * sum / 2.0\n  return kuad\nend\n\ntheta0 = pi/200.0\na = 0.0\nb = theta0\nkuad = kuad_GL1(a,b)\ntau = sqrt(2.0) * kuad/pi;\n\n\n\ntau\n\n\n\nSelain disajikan dalam bentuk ungkapan seperti pers (16) atau bentuk Tabel, beberapa bahasa pemrograman atau paket matematika biasanya juga menyediakan Library, Toolbox atau Package untuk membangkitkan nilai-nilai titik evaluasi fungsi (x_i) beserta nilai bobot terkait (c_i). Sebagai contoh, di dalam Julia hal tersebut difasilitasi oleh Package FastGaussQuadrature seperti berikut.\n\nusing FastGaussQuadrature\n\nfunction fung(y, y0)\n    return 1.0 / sqrt(cos(y) - cos(y0))\nend\n\nfunction kuad_GL(a, b, n)\n    x, c = gausslegendre(n)\n    sum = 0.0\n    for i in 1:n\n        y = (b-a)*x[i]/2.0 + (b+a)/2.0\n        sum += c[i] * fung(y, b)\n    end\n    kuad = (b-a) * sum/2.0\n    return kuad\nend\n\ntheta0 = pi/200.0\na = 0.0\nb = theta0\nkuad = kuad_GL(a, b, 50)\ntau = sqrt(2.0) * kuad / pi;\n\n\n\ntau\n\n\n\n","type":"content","url":"/materi/period-of-pendulum-by-improper-integration-julia#pengaturan-skala-untuk-sebarang-batas-integral","position":7},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Bentuk Lain Metode Kuadratur Numerik"},"type":"lvl2","url":"/materi/period-of-pendulum-by-improper-integration-julia#bentuk-lain-metode-kuadratur-numerik","position":8},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Bentuk Lain Metode Kuadratur Numerik"},"content":"Metode kuadratur Gauss-Legendre merupakan salah satu bentuk dari bentuk umum metode kuadratur yaitu\\int_{a}^b w(x)f(x)dx\\approx \\sum_{i=1}^n c_i f(x_i)\n\nUngkapan tersebut berlaku pada interval [a,b] dan bentuk bobot w(x) tertentu. Keadaan khusus saat a=-1, b=1 dan w(x)=1 maka pers (17) di atas merupakan bentuk dari metode kuadratur Gauss-Legnedre.\n\nInterval [a,b] dan bentuk fungsi bobot w(x) akan terkait dengan fungsi khas dari polinomial orthonormal tertentu sehingga digunakan sebagai penamaan bagi metode kuadratur tersebut. Pemahaman terkait polinomial orthonormal tertentu tersebut akan berguna untuk mendapatkan nilai-nilai x_i dan c_i pada orde pendekatan tertentu.\n\nTabel berikut memberikan daftar dari beberapa bentuk metode kuadratur numerik yang banyak digunakan pada beberapa permasalahan perhitungan yang melibatkan integral tak layak.\n\nInterval pada [a,b]\n\nBentuk fungsi bobot w(x)\n\nPolinomial Orthonormal\n\nNama Metode Kuadratur\n\n[-1,1]\n\n1\n\nPolinomial Legendre\n\nGauss-Legendre\n\n[-1,1]\n\n(1-x)^\\alpha(1+x)^\\beta\n\nPolinomial Jacobi\n\nGauss-Jacobi\n\n[-1,1]\n\n\\frac{1}{\\sqrt{(1-x^2)}}\n\nPolinomial Chebyshev jenis 1\n\nGauss-Chebyshev\n\n[-1,1]\n\n\\sqrt{(1-x^2)}\n\nPolinomial Chebyshev jenis 2\n\nGauss-Chebyshev\n\n[0,\\infty]\n\ne^{-x}\n\nPolinomial Laguerre jenis 2\n\nGauss-Laguerre\n\n[-\\infty,\\infty]\n\ne^{-x^2}\n\nPolinomial Hermite jenis 2\n\nGauss-Hermite\n\n","type":"content","url":"/materi/period-of-pendulum-by-improper-integration-julia#bentuk-lain-metode-kuadratur-numerik","position":9},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Implementasi Bentuk Kuadratur Numerik lainnya: Gauss-Chebyshev"},"type":"lvl2","url":"/materi/period-of-pendulum-by-improper-integration-julia#implementasi-bentuk-kuadratur-numerik-lainnya-gauss-chebyshev","position":10},{"hierarchy":{"lvl1":"Kasus Fisika Non Linear: Osilasi Bandul","lvl2":"Implementasi Bentuk Kuadratur Numerik lainnya: Gauss-Chebyshev"},"content":"Perhitungan periode bandul pada sebarang simpangan T atau \\tau dengan bentuk seperti pers (5) atau (5a) akan lebih sesuai diselesaikan berdasar kuadratur numerik Gauss-Chebyshev, dibanding dengan kuadratur numerik Gauss-Legendre seperti uraian berikut.\n\nTinjau substitusi variabel dalam bentuk ungkapank=\\sin\\frac{\\theta_0}{2};\\quad \\text{dan}\\quad y=\\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}=\\frac{\\sin\\frac{\\theta}{2}}{k}\n\nMaka diperoleh bahwa:y=0\\quad \\text{saat}\\quad \\theta=0;\\quad \\text{dan}\\quad y=1\\quad\\text{saat}\\quad \\theta=\\theta_0\n\nDengan ungkapan tersebut maka diperoleh\\sqrt{\\cos\\theta-\\cos\\theta_0}=\\sqrt{2\\left(\\sin\\frac{\\theta_0}{2}-\\sin\\frac{\\theta}{2}\\right)}=\\sqrt{2}\\sin\\frac{\\theta_0}{2}\\sqrt{1-\\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}}=\\sqrt{2}k\\sqrt{1-y^2}dy=\\frac{1}{2k}\\sqrt{1-\\sin^2\\frac{\\theta}{2}}d\\theta=\\frac{1}{2k}\\sqrt{1-k^2y^2}d\\theta;\\quad\\Longrightarrow\\quad d\\theta=\\frac{2k}{\\sqrt{1-k^2y^2}}dy\n\nUngkapan periode bandul pada sebarang simpangan T atau \\tau dengan bentuk seperti pers (5) atau (5a) maka dapat dinyatakan dalam bentuk lain yaituT=4\\,\\sqrt{\\frac{l}{2g}}\\int_0^{\\theta_0}\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}=4\\,\\sqrt{\\frac{l}{g}}\\int_0^1\\,\\frac{dy}{\\sqrt{1-y^2}\\sqrt{1-k^2y^2}}\n\nDalam bentuk satuan universal, periode (\\tau) berbentuk\\begin{align}\n\\tau&=\\frac{T}{T_0}=\\frac{\\sqrt{2}}{\\pi}\\int_0^{\\theta_0}\\,\\frac{d\\theta}{\\sqrt{\\cos\\theta-\\cos\\theta_0}}=\\frac{2}{\\pi}\\int_0^1\\,\\frac{dy}{\\sqrt{1-y^2}\\sqrt{1-k^2y^2}}\n\\nonumber\\\\\n&=\\frac{1}{\\pi}\\int_{-1}^1\\,\\frac{dy}{\\sqrt{1-y^2}\\sqrt{1-k^2y^2}}\n\\end{align}\n\nMembandingkan pers (18) dan (18a) maka ungkapan tersebut akan sesuai dengan bentuk quadratur numerik  Gauss-Chebyshev yaituw(y)=\\frac{1}{\\sqrt{1-y^2}};\\quad\\text{dan}\\quad f(y)=\\frac{1}{\\sqrt{1-k^2y^2}}\n\nfunction fung(y, k)\n    return 1.0 / sqrt(1.0 - (k*y)^2)\nend\n\nfunction kuad_GC(k, n)\n    x, c = gausschebyshev(n)\n    sum = 0.0\n    for i in 1:n\n        sum += c[i] * fung(x[i], k)\n    end\n    kuad = sum\n    return kuad\nend\n\ntheta0 = pi/200.0\nk = sin(theta0/2.0)\nkuad = kuad_GC(k, 20)\ntau = kuad / pi;\n\n\n\ntau\n\n","type":"content","url":"/materi/period-of-pendulum-by-improper-integration-julia#implementasi-bentuk-kuadratur-numerik-lainnya-gauss-chebyshev","position":11},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul"},"type":"lvl1","url":"/materi/masalah-syarat-awal-julia","position":0},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul"},"content":"","type":"content","url":"/materi/masalah-syarat-awal-julia","position":1},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl2":"Masalah Syarat Awal dengan Metode Runge-Kutta"},"type":"lvl2","url":"/materi/masalah-syarat-awal-julia#masalah-syarat-awal-dengan-metode-runge-kutta","position":2},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl2":"Masalah Syarat Awal dengan Metode Runge-Kutta"},"content":"Persamaan gerak benda bermassa m yang digantungkan pada seutas tali dengan panjang l dan massa diabaikan, di bawah pengaruh medan gravitasi bumi g, adalahm\\frac{d^2 x(t)}{dt^2}=-mg\\sin\\theta(t)\n\nDalam radian, mengingat x(t)=l\\theta(t) dengan \\theta(t) adalah sudut simpangan benda terhadap titik setimbang, maka persamaan gerak tersebut dapat dinyatakan dalam bentuk persamaan diferensial orde dua berikut\\frac{d^2\\theta(t)}{dt^2}=-\\frac{g}{l}\\sin\\theta(t)\n\nDiambil satuan universal atau besaran tak berdimensi bagi besaran waktu yaitu\\tau=\\frac{t}{\\omega_0}\n\nDalam satuan universal tersebut maka persamaan gerak bagi bandul akan dapat diungkapkan dalam bentuk berikut.\\frac{d^2\\theta(\\tau)}{d\\tau^2}=-\\sin\\theta(\\tau)\n\nPenyelesaian persamaan diferensial tersebut secara analitik akan cukup sulit karena berbentuk nonlinear dalam \\theta(\\tau). Untuk keadaan khusus, pada simpangan kecil sedemikian hingga \\sin\\theta(\\tau)\\approx \\theta(\\tau) maka pers (4) di atas dapat didekati oleh bentuk\\frac{d^2\\theta(\\tau)}{d\\tau^2}\\approx-\\theta(\\tau)\n\nPada simpangan kecil ini, umumnya terpenuhi saat simpangan \\theta<10^\\circ, maka penyelesaian pers (5) berbentuk\\theta(\\tau)=\\theta_0\\cos(\\tau)+v_0\\sin(\\tau)\n\nUngkapan tersebut diperoleh dengan asumsi syarat awal bahwa pada saat awal \\tau=0 maka benda berada pada sudut simpangan maksimum di \\theta=\\theta_0 dan kecepatan sudut awal \\left[\\frac{d\\theta}{d\\tau}\\right]_{\\tau=0}=v_0=0.\n\nUntuk sebarang simpangan, yang tidak dibatasi pada simpangan kecil, penyelesaian pers (4) menjadi sulit untuk diperoleh secara analitik sehingga bentuk kompak penyelesaian simpangan seperti diberikan oleh pers (6) menjadi tidak berlaku. Salah satu metode untuk penyelesaian persamaan gerak pada sebarang sudut simpangan tersebut adalah dengan menggunakan metode Euler.","type":"content","url":"/materi/masalah-syarat-awal-julia#masalah-syarat-awal-dengan-metode-runge-kutta","position":3},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"type":"lvl2","url":"/materi/masalah-syarat-awal-julia#metode-euler-untuk-masalah-syarat-awal","position":4},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"content":"","type":"content","url":"/materi/masalah-syarat-awal-julia#metode-euler-untuk-masalah-syarat-awal","position":5},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Skema Eksplisit: Beda Maju (Forward Difference)","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#skema-eksplisit-beda-maju-forward-difference","position":6},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Skema Eksplisit: Beda Maju (Forward Difference)","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"content":"Masalah sayrat awal merupakan suatu bentuk permasalahan ketika informasi terkait sistem fisis pada keadaan tertentu yaitu pada keadaan awal atau saat waktu \\tau=0 telah diketahui dan kemudian diinginkan informasi terkait sistem fisis tersebut pada sebarang waktu \\tau.\n\nUntuk sistem bandul yang telah diuraikan di atas maka diasumsikan bahwa nilai sudut simpangan dan kecepatan sudut pada saat waktu \\tau=0 secara berurutan adalah \\theta_0 dan v_0.  Persamaan gerak bandul seperti diberikan oleh pers (4) dapat ditulis ulang dalam bentuk berikut.\\begin{align}\n\\frac{dv(\\tau)}{d\\tau}&=-\\sin\\theta(\\tau)\\\\\n\\frac{d\\theta(\\tau)}{d\\tau}&=v(\\tau)\n\\end{align}\n\nMemanfaatkan salah satu bentuk pendekatan beda hingga (finite difference) yaitu beda maju (forward difference), ungkapan persamaan diferensial orde satu pada pers (7) dan (8) tersebut akan dapat dinyatakan sebagai bentuk persamaan beda hingga seperti berikut.\\begin{align}\n\\left[\\frac{dv(\\tau)}{d\\tau}\\right]_{\\tau=0}&\\approx\\frac{v_1-v_0}{\\Delta \\tau}=-\\sin\\theta_0 &\\Longrightarrow v_1&=v_0-\\Delta \\tau\\sin\\theta_0\\\\\n\\left[\\frac{d\\theta(\\tau)}{d\\tau}\\right]_{\\tau=0}&\\approx\\frac{\\theta_1-\\theta_0}{\\Delta \\tau}=v_0 &\\Longrightarrow \\theta_1&=\\theta_0+\\Delta \\tau\\,v_0\n\\end{align}\n\nBerdasar ungkapan tersebut maka bentuk umum metode Euler skema eksplisit adalah seperti berikut.\\begin{align}\nv_i&=v_{i-1}-\\Delta \\tau\\sin\\theta_{i-1}\\\\\n\\theta_i&=\\theta_{i-1}+\\Delta \\tau\\,v_{i-1};\\qquad i=1,2,3,\\cdots,N\n\\end{align}\n\nDalam ungkapan tersebut, \\Delta\\tau=\\tau_i-\\tau_{i-1}, v_i\\equiv v(\\tau_i) dan \\theta_i\\equiv \\theta(\\tau_i).\n\nMetode tersebut disebut sebagai metode Euler skema eksplisit karena nilai v_i dan \\theta_i dapat langsung diperoleh ketika nilai-nilai sebelumnya yaitu v_{i-1} dan \\theta_{i-1} telah diketahui.","type":"content","url":"/materi/masalah-syarat-awal-julia#skema-eksplisit-beda-maju-forward-difference","position":7},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Algoritma Penyelesaian Gerak Bandul dengan Skema Eksplisit","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#algoritma-penyelesaian-gerak-bandul-dengan-skema-eksplisit","position":8},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Algoritma Penyelesaian Gerak Bandul dengan Skema Eksplisit","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"content":"Berawal dari keadaan nilai sudut simpangan \\theta_0 dan kecepatan sudut v_0,  maka prosedur untuk memperoleh sudut  simpangan dan kecepatan sudut pada sebarang nilai \\tau adalah seperti berikut\n\nBerikan nilai masukan \\theta_0, v_0 dan \\Delta \\tau\n\nHitung nilai sudut simpangan \\theta_1 dan kecepatan sudut v_1 berdasar ungkapan pers (11) dan (12)\n\nUlangi langkah pada butir 2 untuk memperoleh  sudut simpangan \\theta_i dan kecepatan sudut v_i himgga i=N","type":"content","url":"/materi/masalah-syarat-awal-julia#algoritma-penyelesaian-gerak-bandul-dengan-skema-eksplisit","position":9},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Metode untuk Validasi Hasil","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#metode-untuk-validasi-hasil","position":10},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Metode untuk Validasi Hasil","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"content":"Salah satu cara untuk melekukan pengecekan bahwa hasil komputasi terkait persamaan gerak bandul telah valid atau sahih adalah dengan memantau nilai tenaga total E pada sebarang waktu \\tau. Sistem bandul merupakan sistem konservatif, yaitu tenaga total sistem akan konstan, tidak bergantung pada waktu \\tau. Dengan demikian kriteria bahwa hasil komputasi adalah akurat apabila nilai tenaga total E tidak berubah secara signifikan pada sebarang waktu \\tau. Ungkapan tenaga total E untuk sistem bandul memiliki bentuk berikut.E=\\frac{1}{2}v^2(\\tau)+\\left[1-\\cos\\theta(\\tau)\\right]\n\nfunction bandul_eksplisit(tmax, N, theta0, omega0)\n    tau = range(0.0, tmax, length=N)\n    dtau = tau[2] - tau[1]\n    theta = zeros(N)\n    omega = zeros(N)\n    tenaga = zeros(N)\n    theta[1] = theta0\n    omega[1] = omega0\n    tenaga[1] = omega[1]^2/2.0 + (1.0 - cos(theta[1]))\n    for i in 1:N-1\n        theta[i+1] = theta[i] + dtau * omega[i]\n        omega[i+1] = omega[i] - dtau * sin(theta[i])\n        tenaga[i+1] = omega[i+1]^2/2.0 + (1.0 - cos(theta[i+1]))\n    end\n    return tau, theta, omega, tenaga\nend\n\n\n\ntmax=10\nN=100\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_eksplisit(tmax,N,theta0,omega0)\n\n\n\nusing Plots\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Euler: skema Forward Difference\", lw=2)\n\n\n\ntmax=10\nN=100000\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_eksplisit(tmax,N,theta0,omega0)\n\n\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Euler: skema Forward Difference\", lw=2)\n\n\n\nDua hasil pada nilai \\Delta\\tau yang berbeda di atas menunjukkan bahwa hasil komputasi persamaan gerak bandul dengan metode Euler skema eksplisit akan sahih dan teliti ketika nilai \\Delta\\tau adalah begitu kecil. Ketika \\Delta\\tau tidak cukup kecil maka hasil komputasi menjadi kurang sahih karena nilai tenaga total E nampak tidak konstan. Hasil ini merupakan indikator bahwa metode Euler skema eksplisit memiliki kelemahan yaitu berpotensi untuk tidak stabil.\n\n","type":"content","url":"/materi/masalah-syarat-awal-julia#metode-untuk-validasi-hasil","position":11},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Skema Implisit: Beda Mundur (Backward Difference)","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#skema-implisit-beda-mundur-backward-difference","position":12},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Skema Implisit: Beda Mundur (Backward Difference)","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"content":"Upaya unuk mencapai hasil komputasi yang stabil akan dapat dilakukan dengan menggunakan metode Euler skema implisit. Berbeda dengan metode Euler skema eksplisit yang memanfaatkan pendekatan beda maju (forward difference), maka metode Euler skema impisit akan memanfaatkan pendekatan beda mundur (backward difference) bagi operasi diferensial orde satu dalam bentuk berikut.\\begin{align}\n\\left[\\frac{dv(\\tau)}{d\\tau}\\right]_{\\tau=\\tau_1}&\\approx\\frac{v_1-v_0}{\\Delta \\tau}=-\\sin\\theta_1 &\\Longrightarrow v_1&=v_0-\\Delta \\tau\\sin\\theta_1\\\\\n\\left[\\frac{d\\theta(\\tau)}{d\\tau}\\right]_{\\tau=\\tau_1}&\\approx\\frac{\\theta_1-\\theta_0}{\\Delta \\tau}=v_1 &\\Longrightarrow \\theta_1&=\\theta_0+\\Delta \\tau\\,v_1\n\\end{align}\n\nBerdasar ungkapan tersebut maka bentuk umum metode Euler skema implisit adalah seperti berikut.\\begin{align}\nv_i&=v_{i-1}-\\Delta \\tau\\sin\\theta_i\\\\\n\\theta_i&=\\theta_{i-1}+\\Delta \\tau\\,v_i;\\qquad i=1,2,3,\\cdots,N\n\\end{align}\n\nMetode tersebut disebut sebagai metode Euler skema implisit karena nilai v_i dan \\theta_i tidak otomatis dapat langsung diperoleh ketika nilai-nilai sebelumnya yaitu v_{i-1} dan \\theta_{i-1} telah diketahui.\n\nSalah satu cara untuk mendapatkan nilai v_i dan \\theta_i berdasar metode Euler skema implisit tersebut adalah dengan memanfaatkan pencarian akar suatu fungsi (root finding) atau pencarian titik nol (zeros) menggunakan metode Newton-Raphson.\n\nBentuk fungsi yang akan digunakan dalam proses pencarian akar dapat disusun dengan mensubstitusikan pers (16) ke pers (17) sehingga diperoleh ungkapan seperti berikut.\\theta_i=\\theta_{i-1}+\\Delta \\tau\\left(v_{i-1}-\\Delta \\tau\\sin\\theta_i\\right)\n\nAtau dapat ditulis ulang dalam bentuk:f(\\theta_i)=\\theta_i+\\Delta \\tau^2\\sin\\theta_i-\\Delta \\tau v_{i-1}-\\theta_{i-1}=0\n\nPenggunaan metode Newton-Raphson dapat memanfaatkan source code yang telah disampaikan pada materi kuliah atau menggunakan modul Scipy yaitu scipy.optimize.newton.\n\nNilai coba \\theta_i, yaitu \\theta_i^0 yang diperlukan untuk menjalankan metode Newton-Raphson dapat dipilih dari penyelesaian saat simpangan kecil seperti diberikan oleh pers (6) yaitu\\theta_i^0=\\theta_0\\cos(\\tau_i)+v_0\\sin(\\tau_i)\n\nusing Roots\n\nfunction bandul_implisit(tmax, N, theta0, omega0)\n    tau = range(0.0, tmax, length=N)\n    dtau = tau[2] - tau[1]\n    theta = zeros(N)\n    omega = zeros(N)\n    tenaga = zeros(N)\n    theta[1] = theta0\n    omega[1] = omega0\n    tenaga[1] = omega[1]^2/2.0 + (1.0 - cos(theta[1]))\n    for i in 1:N-1\n        x_init = theta0 * cos(tau[i+1]) + omega0 * sin(tau[i+1])\n        x0 = theta[i]\n        v0 = omega[i]\n        f(x) = x + dtau^2 * sin(x) - dtau * v0 - x0\n        df(x) = 1.0 + dtau^2 * cos(x)\n        theta[i+1] = find_zero((f, df), x_init, Roots.Newton())\n        omega[i+1] = omega[i] - dtau * sin(theta[i+1])\n        tenaga[i+1] = omega[i+1]^2/2.0 + (1.0 - cos(theta[i+1]))\n    end\n    return tau, theta, omega, tenaga\nend\n\n\n\ntmax=10\nN=100\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_implisit(tmax,N,theta0,omega0)\n\n\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Euler: skema Backward Difference\", lw=2)\n\n\n\ntmax=10\nN=100000\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_implisit(tmax,N,theta0,omega0)\n\n\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Euler: skema Backward Difference\", lw=2)\n\n\n\nDua hasil pada nilai \\Delta\\tau yang berbeda di atas menunjukkan bahwa hasil komputasi persamaan gerak bandul dengan metode Euler skema implisit beda mundur akan sahih dan teliti ketika nilai \\Delta\\tau adalah begitu kecil. Ketika \\Delta\\tau tidak cukup kecil maka hasil komputasi menjadi kurang sahih karena nilai tenaga total E nampak tidak konstan. Namun berbeda dengan skema eksplisit, hasil komputasi yang kurang sahih pada skema implist beda mundur ini nampak tidak menunjukkan potensi tidak stabil karena nilai tenaga semakin saat waktu semakin besar. Hasil ini merupakan indikator bahwa metode Euler skema implisit beda mundur  memiliki sedikit kelebihan dibanding metode Euler skema eksplisit karena tidak berpotensi untuk tidak stabil, meskipun masih sama-sama memiliki kelemahan yaitu memerlukan nilai \\Delta\\tau yang  begitu kecil.\n\n","type":"content","url":"/materi/masalah-syarat-awal-julia#skema-implisit-beda-mundur-backward-difference","position":13},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Skema Implisit: Beda Terpusat (Central Difference)","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#skema-implisit-beda-terpusat-central-difference","position":14},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Skema Implisit: Beda Terpusat (Central Difference)","lvl2":"Metode Euler untuk Masalah Syarat Awal"},"content":"Hasil di atas menunjukkan bahwa masalah ketakstabilan yang terjadi pada metode Euler skema eksplisit akan dapat dihindari ketika digunakan metode Euler skema implisit. Meskipun metode Euler skema implisit membutuhkan waktu komputasi yang lebih besar, kerena ada tambahan proses pencarian akar, namun adanya jaminan kestabilan menyebabkan metode tersebut lebih menjadi pilihan dibanding metode Euler eksplisit.\n\nUntuk mendapatkan hasil yang lebih teliti, selain jaminan kestabilan, maka dapat memanfaatkan pendekatan beda terpusat (central difference) bagi operasi diferensial orde satu dalam bentuk berikut.\\begin{align}\n\\left[\\frac{dv(\\tau)}{d\\tau}\\right]_{\\tau=\\tau_{1/2}}&\\approx\\frac{v_1-v_0}{\\Delta \\tau}=-\\sin\\theta_{1/2}\\approx-\\frac{\\sin\\theta_0+\\sin\\theta_1}{2} &\\Longrightarrow v_1&=v_0-\\\\\n&&&\\frac{\\Delta \\tau}{2}\\left(\\sin\\theta_1+\\sin\\theta_0\\right)\\\\\n\\left[\\frac{d\\theta(\\tau)}{d\\tau}\\right]_{\\tau=\\tau_{1/2}}&\\approx\\frac{\\theta_1-\\theta_0}{\\Delta \\tau}=v_{1/2}\\approx\\frac{v_0+v_1}{2} &\\Longrightarrow \\theta_1&=\\theta_0+\\frac{\\Delta \\tau}{2}\\left(v_1+v_0\\right)\n\\end{align}\n\nBerdasar ungkapan tersebut maka bentuk umum metode Euler skema implisit adalah seperti berikut.\\begin{align}\nv_i&=v_{i-1}-\\frac{\\Delta \\tau}{2}\\left(\\sin\\theta_i+\\sin\\theta_{i-1}\\right)\\\\\n\\theta_i&=\\theta_{i-1}+\\frac{\\Delta \\tau}{2}\\left(v_i+v_{i-1}\\right);\\qquad i=1,2,3,\\cdots,N\n\\end{align}\n\nBentuk fungsi yang akan digunakan dalam proses pencarian akar dapat disusun dengan mensubstitusikan pers (12b) ke pers (13b) sehingga diperoleh ungkapan seperti berikut.\\theta_i=\\theta_{i-1}+\\frac{\\Delta \\tau}{2}\\left[v_{i-1}-\\frac{\\Delta \\tau}{2}\\left(\\sin\\theta_i+\\sin\\theta_{i-1}\\right)+v_{i-1}\\right]\n\nAtau dapat ditulis ulang dalam bentuk:f(\\theta_i)=\\theta_i+\\frac{\\Delta \\tau^2}{4}\\left(\\sin\\theta_i+\\sin\\theta_{i-1}\\right)-\\Delta \\tau v_{i-1}-\\theta_{i-1}=0\n\nfunction bandul_implisit_terpusat(tmax, N, theta0, omega0)\n    tau = range(0.0, tmax, length=N)\n    dtau = tau[2] - tau[1]\n    theta = zeros(N)\n    omega = zeros(N)\n    tenaga = zeros(N)\n    theta[1] = theta0\n    omega[1] = omega0\n    tenaga[1] = omega[1]^2/2.0 + (1.0 - cos(theta[1]))\n    for i in 1:N-1\n        x0 = theta[i]\n        v0 = omega[i]\n        # Initial guess using small angle solution\n        x_init = theta0 * cos(tau[i+1]) + omega0 * sin(tau[i+1])\n        f(x) = x + dtau^2 * sin(x)/4.0 + dtau^2 * sin(x0)/4.0 - dtau * v0 - x0\n        df(x) = 1.0 + dtau^2 * cos(x)/4.0\n        theta[i+1] = find_zero((f, df), x_init, Roots.Newton())\n        omega[i+1] = omega[i] - dtau * sin(theta[i+1])/2.0 - dtau * sin(theta[i])/2.0\n        tenaga[i+1] = omega[i+1]^2/2.0 + (1.0 - cos(theta[i+1]))\n    end\n    return tau, theta, omega, tenaga\nend\n\n\n\ntmax=10\nN=100\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_implisit_terpusat(tmax,N,theta0,omega0)\n\n\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Euler: skema Central Difference\", lw=2)\n\n\n\nNampak bahwa dengan pengambilan \\Delta\\tau yang tidak terlalu kecil maka metode Euler skema impisit dengan pendekatan beda terpusat dapat memberikan hasil yang teliti dan stabil.\n\n","type":"content","url":"/materi/masalah-syarat-awal-julia#skema-implisit-beda-terpusat-central-difference","position":15},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl2":"Metode Runge-Kutta"},"type":"lvl2","url":"/materi/masalah-syarat-awal-julia#metode-runge-kutta","position":16},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl2":"Metode Runge-Kutta"},"content":"","type":"content","url":"/materi/masalah-syarat-awal-julia#metode-runge-kutta","position":17},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Runge-Kutta Orde 2","lvl2":"Metode Runge-Kutta"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#runge-kutta-orde-2","position":18},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Runge-Kutta Orde 2","lvl2":"Metode Runge-Kutta"},"content":"Berdasar uraian dan contoh di atas maka dapat dipahami bahwa metode Euler memiliki kelemahan untuk menyelesaikan masalah syarat awal. Metode Euler skema eksplisit memiliki kelemahan pada ketakstabilan serta ketelitian hasil sehingga membutuhkan interval waktu \\Delta \\tau yang amat kecil. Metode Euler skema implisit beda mundur (backward difference) mampu mengatasi ketakstabilan namun masih membutuhkan interval waktu \\Delta \\tau yang amat kecil. Metode Euler skema implisit beda terpusat (central difference) mampu mengatasi ketakstabilan dan ketelitian yang tidak membutuhkan interval waktu \\Delta \\tau yang amat kecil. Meskipun demikian, metode Euler skema implisit beda terpusat (central difference) masih memiliki kekurangan yaitu memerlukan langkah komputasi yang relatif mahal karena melibatkan pencarian akar untuk tiap nilai. Metode Runge-Kutta mengatasi kekurangan yang ada pada metode Euler, terutama dalam hal yang terkait dengan ketelitian hasil serta tidak memerlukan langkah komputasi yang relatif mahal karena berbentuk eksplisit.\n\nTinjau  metode Euler skema implisit beda terpusat (central difference) dalam bentuk ungkapan pers (12a) berikut.\\left[\\frac{dv(\\tau)}{d\\tau}\\right]_{\\tau=\\tau_{1/2}}\\approx\\frac{v_1-v_0}{\\Delta \\tau}=-\\sin\\theta_{1/2}\n\nJika dianggap bahwa \\sin\\theta_{1/2}\\equiv\\sin\\left[\\theta\\left(\\tau_0+\\tfrac{\\Delta\\tau}{2}\\right)\\right] dapat diperoleh berdasar pendekatan deret hingga orde 1 yaitu\\sin\\theta_{1/2}\\equiv\\sin\\left[\\theta\\left(\\tau_0+\\tfrac{\\Delta\\tau}{2}\\right)\\right]\\approx\\sin\\left(\\theta_0+\\frac{\\Delta\\tau}{2}\\left[\\frac{d\\theta}{d\\tau}\\right]_{\\tau=\\tau_0}\\right)\\approx\\sin\\left(\\theta_0+\\frac{\\Delta\\tau}{2}v_0\\right)\n\nDengan cara yang sama maka bentuk ungkapan pers (13a) juga dapat disajikan seperti ungkapan pers (15) dan (16) tersebut. Maka  metode Euler skema implisit beda terpusat (central difference)  dapat diselesaikan dengan langkah eksplisit berikut.\\begin{align}\nk_1^{(1)}&=-\\sin\\theta_0\\\\\nk_1^{(2)}&=v_0\\\\\nk_2^{(1)}&=-\\sin\\left(\\theta_0+\\frac{\\Delta\\tau}{2}k_1^{(2)}\\right)\\\\\nk_2^{(2)}&=v_0+\\frac{\\Delta\\tau}{2}k_1^{(1)}\\\\\nv_1&=v_0+\\Delta\\tau k_2^{(1)}\\\\\n\\theta_1&=\\theta_0+\\Delta\\tau k_2^{(2)}\n\\end{align}\n\nUngkapan pada pers (17) tersebut dapat dilakukan secara berulang pada setiap putaran ke i dengan i=1,2,3\\cdots,N. Langkah seperti diberikan oleh pers (17) disebut sebagai metode Runge-Kutta orde 2 dengan bentuk umum seperti berikut.\\begin{align}\nk_1^{(1)}&=-\\sin\\theta_{i-1}\\\\\nk_1^{(2)}&=v_{i-1}\\\\\nk_2^{(1)}&=-\\sin\\left(\\theta_{i-1}+\\frac{\\Delta\\tau}{2}k_1^{(2)}\\right)\\\\\nk_2^{(2)}&=v_{i-1}+\\frac{\\Delta\\tau}{2}k_1^{(1)}\\\\\nv_i&=v_{i-1}+\\Delta\\tau k_2^{(1)}\\\\\n\\theta_i&=\\theta_{i-1}+\\Delta\\tau k_2^{(2)};\\qquad i=1,2,3,\\cdots,N\n\\end{align}\n\nSource code berikut merupakan implementasi metode Runge-Kutta orde 2.\n\nfunction bandul_RK2(tmax, N, theta0, omega0)\n    tau = range(0.0, tmax, length=N)\n    dtau = tau[2] - tau[1]\n    theta = zeros(N)\n    omega = zeros(N)\n    tenaga = zeros(N)\n    theta[1] = theta0\n    omega[1] = omega0\n    tenaga[1] = omega[1]^2/2.0 + (1.0 - cos(theta[1]))\n    for i in 1:N-1\n        k1_1 = -sin(theta[i])\n        k1_2 = omega[i]\n        k2_1 = -sin(theta[i] + dtau * k1_2 / 2.0)\n        k2_2 = omega[i] + dtau * k1_1 / 2.0\n        omega[i+1] = omega[i] + dtau * k2_1\n        theta[i+1] = theta[i] + dtau * k2_2\n        tenaga[i+1] = omega[i+1]^2/2.0 + (1.0 - cos(theta[i+1]))\n    end\n    return tau, theta, omega, tenaga\nend\n\n\n\ntmax=10\nN=100\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_RK2(tmax,N,theta0,omega0)\n\n\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Runge-Kutta: Orde 2 \", lw=2)\n\n\n\nNampak dari hasil di atas bahwa metode Runget-Kutta orde 2 dapat memberikan hasil yang teliti seperti metode Euler skema implisit beda terpusat (central difference), dengan tambahan fitur yaitu berdasar skema eksplisit.\n\n","type":"content","url":"/materi/masalah-syarat-awal-julia#runge-kutta-orde-2","position":19},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Runge-Kutta Orde 4","lvl2":"Metode Runge-Kutta"},"type":"lvl3","url":"/materi/masalah-syarat-awal-julia#runge-kutta-orde-4","position":20},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Gerak Bandul","lvl3":"Runge-Kutta Orde 4","lvl2":"Metode Runge-Kutta"},"content":"Metode Runge-Kutta orde 2 yang diuraikan di atas memiliki ketelitian sebanding dengan orde \\Delta\\tau^3. APabila diinginkan ketelitian yang lebih tinggi hingga sebanding dengan orde \\Delta\\tau^5, maka dapat digunakan metode Runge-Kutta orde 4 dengan langkah seperti diberikan berikut.\\begin{align}\nk_1^{(1)}&=-\\sin\\theta_{i-1}\\\\\nk_1^{(2)}&=v_{i-1}\\\\\nk_2^{(1)}&=-\\sin\\left(\\theta_{i-1}+\\frac{\\Delta\\tau}{2}k_1^{(2)}\\right)\\\\\nk_2^{(2)}&=v_{i-1}+\\frac{\\Delta\\tau}{2}k_1^{(1)}\\\\\nk_3^{(1)}&=-\\sin\\left(\\theta_{i-1}+\\frac{\\Delta\\tau}{2}k_2^{(2)}\\right)\\\\\nk_3^{(2)}&=v_{i-1}+\\frac{\\Delta\\tau}{2}k_2^{(1)}\\\\\nk_4^{(1)}&=-\\sin\\left(\\theta_{i-1}+k_3^{(2)}\\right)\\\\\nk_4^{(2)}&=v_{i-1}+k_3^{(1)}\\\\\nv_i&=v_{i-1}+\\frac{\\Delta\\tau}{6}\\left(k_1^{(1)}+2.0*k_2^{(1)}+2.0*k_3^{(1)}+k_4^{(1)}\\right)\\\\\n\\theta_i&=\\theta_{i-1}+\\frac{\\Delta\\tau}{6}\\left(k_1^{(2)}+2.0*k_2^{(2)}+2.0*k_3^{(2)}+k_4^{(2)}\\right);\\qquad i=1,2,3,\\cdots,N\n\\end{align}\n\nSource code berikut merupakan implementasi metode Runge-Kutta orde 4.\n\nfunction bandul_RK4(tmax, N, theta0, omega0)\n    tau = range(0.0, tmax, length=N)\n    dtau = tau[2] - tau[1]\n    theta = zeros(N)\n    omega = zeros(N)\n    tenaga = zeros(N)\n    theta[1] = theta0\n    omega[1] = omega0\n    tenaga[1] = omega[1]^2/2.0 + (1.0 - cos(theta[1]))\n    for i in 1:N-1\n        k1_1 = -sin(theta[i])\n        k1_2 = omega[i]\n        k2_1 = -sin(theta[i] + dtau * k1_2 / 2.0)\n        k2_2 = omega[i] + dtau * k1_1 / 2.0\n        k3_1 = -sin(theta[i] + dtau * k2_2 / 2.0)\n        k3_2 = omega[i] + dtau * k2_1 / 2.0\n        k4_1 = -sin(theta[i] + dtau * k3_2)\n        k4_2 = omega[i] + dtau * k3_1\n        omega[i+1] = omega[i] + dtau * (k1_1 + 2.0*k2_1 + 2.0*k3_1 + k4_1) / 6.0\n        theta[i+1] = theta[i] + dtau * (k1_2 + 2.0*k2_2 + 2.0*k3_2 + k4_2) / 6.0\n        tenaga[i+1] = omega[i+1]^2/2.0 + (1.0 - cos(theta[i+1]))\n    end\n    return tau, theta, omega, tenaga\nend\n\n\n\ntmax=30\nN=100\ntheta0=pi/10.0\nomega0=0.0\n\n\n\ntau,theta,omega,tenaga=bandul_RK4(tmax,N,theta0,omega0)\n\n\n\nplot(tau,[theta,omega,tenaga], label=[\"θ (rad)\" \"ω (rad/s)\" \"E (J)\"], xlabel=\"t (s)\", ylabel=\"Nilai\", title=\"Metode Runge-Kutta: Orde 4\", lw=2)\n\n\n\nNampak dari hasil di atas bahwa metode Runget-Kutta orde 4 dapat memberikan hasil yang teliti bahkan ketika diambil nilai \\Delta\\tau=0.3.","type":"content","url":"/materi/masalah-syarat-awal-julia#runge-kutta-orde-4","position":21},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson"},"type":"lvl1","url":"/materi/masalah-syarat-batas-julia","position":0},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson"},"content":"","type":"content","url":"/materi/masalah-syarat-batas-julia","position":1},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Masalah Syarat Batas"},"type":"lvl2","url":"/materi/masalah-syarat-batas-julia#masalah-syarat-batas","position":2},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Masalah Syarat Batas"},"content":"Beberapa masalah fisika dapat disajikan oleh model yang diwakili oleh persamaan Poisson dalam bentuk berikut.\\nabla^2\\phi(\\vec{r})=f(\\vec{r})\n\nDalam ungkapan di atas, \\nabla^2 merupakan operator Laplasan sedang \\phi(\\vec{r}) dan f(\\vec{r}) merupakan fungsi bernilai komplek atau real. Penyelesaian persamaan Poisson merupakan upaya untuk memperoleh fungsi \\phi(\\vec{r}) ketika f(\\vec{r}) diketahui atau diberikan.\n\nSebagai gambaran, dalam ruang 3 dimensi pada koordinat Kartesan maka persamaan Poisson akan memiliki bentuk berikut.\\left(\\frac{\\partial ^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial x^2}\\right)\\phi(x,y,x)=f(x,y,z)\n\nSalah satu contoh sistem fisis yang memenuhi persamaan Poisson adalah masalah untuk menemukan distribusi potensial gravitasi pada seluruh ruang \\phi(r) oleh adanya tarikan medan gravitasi akibat rapat massa \\rho. Ungkapan persamaan Poisson untuk potensial gravitasi mengambil bentuk berikut.\\nabla^2\\phi=4\\pi G\\rho\n\ndengan G adalah tetapan gravitasi umum.\n\nPenyelesaian bagi pers (2) untuk benda berbentuk titik dengan massa m akan memberikan potensial gravitasi \\phi(r) pada suatu jarak radial r seperti berikut.\\phi(r)=-\\frac{Gm}{r}\n\nBentuk di atas tidak lain merupakan ungkapan Hukum Newton tentang gravitasi umum.\n\nContoh lain sistem fisis yang memenuhi persamaan Poisson adalah masalah untuk menemukan distribusi potensial listrik pada seluruh ruang V(r) oleh adanya distribusi rapat muatan \\rho. Ungkapan persamaan Poisson untuk potensial listrik mengambil bentuk berikut.\\nabla^2 V=-\\frac{\\rho}{\\epsilon}\n\ndengan \\epsilon adalah permitivitas medium.\n\nPenyelesaian bagi pers (3) untuk muatan berbentuk titik dengan besar q akan memberikan potensial listrik V(r) pada suatu jarak radial r seperti berikut.V(r)=\\frac{q}{4\\pi\\epsilon r}\n\nBentuk di atas tidak lain merupakan ungkapan Hukum Coulomb tentang listrik statis.\n\nSecara umum, saat distribusi rapat massa atau rapat muatan berbentuk sebarang maka penyelesaian persamaan Poisson menjadi tidak mudah dan diperlukan prosedur komputasi untuk menyelesaikan masalah tersebut.","type":"content","url":"/materi/masalah-syarat-batas-julia#masalah-syarat-batas","position":3},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Penyelesaian dalam Ruang Satu Dimensi (1-D)"},"type":"lvl2","url":"/materi/masalah-syarat-batas-julia#penyelesaian-dalam-ruang-satu-dimensi-1-d","position":4},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Penyelesaian dalam Ruang Satu Dimensi (1-D)"},"content":"Sebagai gambaran, diberikan bentuk rapat muatan yang tergantung pada jarak radial saja yaitu\\rho(r)=\\epsilon e^{-r}\n\nMengingat terjadinya simetri bola, maka persamaan Poisson dalam ruang tiga dimensi dapat dibawa ke masalah pada ruang satu dimensi menjadi\\frac{1}{r^{2}}\\frac{d}{dr}\\left(r^{2}\\frac{dV(r)}{dr}\\right)=\\frac{d^2V(r)}{dr^2}+\\frac{2}{r}\\frac{dV(r)}{dr}=-e^{-r}\n\nUngkapan tersebut dapat dinyatakan dalam bentuk berikut.r\\frac{d^2V(r)}{dr^2}+2\\frac{dV(r)}{dr}=-re^{-r}\n\nPenyelesaian pers (5) dapat dilakukan secara analitik dengan bentuk potensial berikut:V(r)=\\frac{2}{r}-\\left(\\frac{2}{r}+1\\right)e^{-r}\n\nKarena \\rho(r) tidak singular di r = 0 maka V(0) bernilai berhingga dan memiliki perilaku seperti potensial Coulomb di r\\rightarrow\\infty yaitu V(r\\rightarrow\\infty) = 1/r. Berdasar penyelesaian analitik tersebut maka syarat batas pada r=0 dan r\\rightarrow\\infty dapat diambil dalam nilai berikut.V(0)=1;\\qquad V(r\\rightarrow \\infty)=\\frac{2}{r}","type":"content","url":"/materi/masalah-syarat-batas-julia#penyelesaian-dalam-ruang-satu-dimensi-1-d","position":5},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Metode Beda Hingga (Finite Difference)"},"type":"lvl2","url":"/materi/masalah-syarat-batas-julia#metode-beda-hingga-finite-difference","position":6},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Metode Beda Hingga (Finite Difference)"},"content":"Masalah syarat batas merupakan suatu bentuk permasalahan ketika informasi terkait sistem fisis pada keadaan tertentu yaitu pada bagian batas dari ruang yang ditinjau telah diketahui dan kemudian diinginkan informasi terkait sistem fisis tersebut pada daerah yang dilingkupi oleh batas tersebut.\n\nUntuk ruang 1 dimensi, yang dimaksud bagian batas adalah 2 titik pada bagian ujung sumbu.\n\nUntuk ruang 2 dimensi, yang dimaksud bagian batas adalah titik-titik yang mengelilingi bagian tepi bidang.\n\nSedangkan untuk ruang 3 dimensi, yang dimaksud bagian batas adalah titik-titik yang melingkupi bagian permukaan ruang.\n\nPendekatan beda hingga (finite difference) menggunakan skema beda terpusat (central difference) bagi bentuk turunan satu kali dan dua kali sebarang fungsi f(x) adalah sebagai berikut.\\begin{align}\n\\left.\\frac{df(x)}{dx}\\right]_{x=x_i}&\\approx\\frac{f_{i+1}-f_{i-1}}{2h}\\\\\n\\left.\\frac{d^2 f(x)}{dx^2}\\right]_{x=x_i}&\\approx \\frac{f_{i+1}-2f_i+f_{i-1}}{h^2}\n\\end{align}\n\nDalam ungkapan di atas, h=x_i-x_{i-1}, x_i=x_0+ih dan f_i\\equiv f(x_i).\n\nDengan pendekatan tersebut maka persamaan diferensial dalam pers (5b) akan dapat dinyatakan dalam bentuk persamaan beda hingga yaitur_i\\left(\\frac{V_{i+1}-2V_i+V_{i-1}}{h^2}\\right)+2\\left(\\frac{V_{i+1}-V_{i-1}}{2h}\\right)=-r_i e^{-r_i}\n\nUngkapan tersebut dapat dinyatakan dalam bentuk lain sebagai berikut.\\left(r_i-h\\right)V_{i-1}-2r_iV_i+\\left(r_i+h\\right)V_{i+1}=r_{i-1}V_{i-1}-2r_iV_i+r_{i+1}V_{i+1}=-h^2 r_i e^{-r_i}\n\nUngkapan bagi syarat batas dapat dinyatakan sebagai V_0=1 dan V_{N+1}=\\tfrac{2}{r_{N+1}} dimana r_0=0 dan N adalah bilangan bulat positip yang diambil bernilai cukup besar sedemikian hingga r_{N+1}\\rightarrow\\infty.\n\nDengan memperhitungkan nilai pada kedua batas yaitu V_0=1 dan V_{N+1}=\\tfrac{2}{r_{N+1}} maka pers (7) akan berujud menjadi sejumlah N persamaan simultan yang mengandung N variabel yang perlu dicari yaitu \\left\\{V_1, V_2,\\dots,V_N\\right\\}. Apabila sejumlah besaran yang akan dicari tersebut, yaitu \\left\\{V_i; i=1.2,3,\\dots,N\\right\\} dinyatakan dalam bentuk matrik kolom V, maka sejumlah N persamaan simultan tersebut dapat ditulis dalam bentuk perkalian matrik sebagaiAV=b\n\nDalam bentuk eksplisit akan berbentuk berikut\\left(\n\\begin{array}{cccccc} \n-2r_1&r_2&0&\\ldots&\\ldots&0\\\\\nr_1&-2r_2&r_3&0&\\ldots&0\\\\\n\\vdots&\\vdots&\\ddots&\\vdots&\\vdots&\\vdots\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots&\\vdots\\\\\n\\vdots&\\ldots&0&r_{N-2}&-2r_{N-1}&r_N\\\\\n0&\\ldots&\\ldots&0&r_{N-1}&-2r_N\n\\end{array}\n\\right)\n\\left(\n\\begin{array}{c}\nV_1\\\\\nV_2\\\\\n\\vdots\\\\\n\\vdots\\\\\nV_{N-1}\\\\\nV_N\n\\end{array}\n\\right)=\n\\left(\n\\begin{array}{c}\n-h^2\\,r_1\\,e^{-r_1}-r_0V_0\\\\\n-h^2\\,r_2\\,e^{-r_2}\\\\\n\\vdots\\\\\n\\vdots\\\\\n-h^2\\,r_{N-1}\\,e^{-r_{N-1}}\\\\\n-h^2\\,r_N\\,e^{-r_N}-r_{N+1}V_{N+1}\n\\end{array}\n\\right)\n\nBerikut adalah source-code bagi uraian prosedur komputasi tersebut.\n\nusing LinearAlgebra\n\nrmax = 10.0\nN = 1000\nh = rmax / (N - 1)\nr = collect(range(h, rmax; length=N))\nr0 = 0.0\nrN1 = rmax + h\nV0 = 1.0\nVN1 = 2.0 / rN1\nV_ref = 2.0 ./ r .- (2.0 ./ r .+ 1.0) .* exp.(-r);\n\n\n\nfunction gen_A(N, r)\n    b1 = r[2:end]\n    b2 = -2.0 .* r\n    b3 = r[1:end-1]\n    A = diagm(1 => b1) + diagm(0 => b2) + diagm(-1 => b3)\n    return A\nend\n\n\n\nfunction gen_b(N, h, r, V0, VN1, r0, rN1)\n    b = -h^2 .* r .* exp.(-r)\n    b[1] -= r0 * V0\n    b[N] -= rN1 * VN1\n    return b\nend\n\n\n\nA=gen_A(N,r)\nb=gen_b(N,h,r,V0,VN1,r0,rN1);\n\n\n\nV = A \\ b;\n\n\n\nusing Plots\nusing LaTeXStrings\n\nplot(r,[V,V_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"V(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\nphi = V .* r\nplot(r,phi,xlabel=\"r\", ylabel=L\"$\\phi(r)$\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\n","type":"content","url":"/materi/masalah-syarat-batas-julia#metode-beda-hingga-finite-difference","position":7},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Dekomposisi LU"},"type":"lvl2","url":"/materi/masalah-syarat-batas-julia#dekomposisi-lu","position":8},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Dekomposisi LU"},"content":"Dalam kebanyakan permasalahan, rapat muatan dalam peubah radial dapat diambil pada bentuk beragam dan kemudian ditentukan konfigurasi potensial listrik untuk berbagai bentuk tersebut. Untuk permasalahan semacam ini, maka prosedur komputasi dekomposisi LU akan lebih tepat untuk dipilih karena operasi yang melibatkan matrik A, yaitu operasi eleminasi atau invers matrik, cukup dilakukan satu kali dan untuk seterusnya cukup menggunakan operasi substitusi maju dan substitusi mundur.\n\nSeperti yang telah diuraikan pada materi penyelesaian persamaan simultas, prinsip dasar metode dekomposisi LU adalah mengubah matrik persegi A menjadi perkalian dua matrik persegi yaitu matrik segitiga bawah L dengan matrik segitiga atas U dalam bentuk berikut.PA=LU\n\nMatrik persegi P disebut matrik permutasi yang berperan untuk mempertukarkan baris atau kolom agar tidak terjadi singularitas. Sifat matrik permutasi adalah P^TP=I atau P^{-1}=P^T. Dengan demikian penyelesaian persamaan simultan akan berubah menjadi\\begin{align}\nAV&=P^{-1}LUV=P^{-1}LW=P^{-1}Z=b; \\qquad\\mathrm{dengan}\\\\\nP^{-1}Z&=b\\quad\\mathrm{atau}\\quad Z=Pb\\quad\\mathrm{dilanjutkan}\\\\\nLW&=Z\\quad\\mathrm{kemudian}\\\\  \nUV&=W\n\\end{align}\n\nDalam ungkapan matrik segitiga atas U dan matrik segitiga bawah L diberikan oleh bentukU=\\begin{pmatrix}\nu_{11}&u_{12}&u_{13}&\\cdots&u_{1N}\\\\\n0&u_{22}&\\cdots&\\cdots&u_{2N}\\\\\n\\vdots&\\vdots&\\vdots&\\vdots&\\vdots\\\\\n0&0&0&\\cdots&u_{NN}\n\\end{pmatrix};\\qquad\nL=\\begin{pmatrix}\n1&0&0&\\cdots&0\\\\\n0&1\\cdots&\\cdots&0\\\\\n\\vdots&\\vdots&\\vdots&\\vdots&\\vdots\\\\\nl_{N1}&l_{N2}&l_{N3}&\\cdots&1\n\\end{pmatrix}\n\nDengan ungkapan tersebut maka matrik kolom W dapat diperoleh melalui proses substitusi maju, yaitu diperoleh nilai W_1, W_2 dan seterusnya hingga W_N. Setelah matrik kolom W diperoleh, selanjutnya matrik kolom V dihitung melalui proses substitusi balik, yaitu diperoleh nilai V_N, V_{N-1} dan seterusnya hingga V_1.\n\nfunction forw_subs(A, b)\n    n = size(A, 1)\n    x = zeros(eltype(b), n)\n    x[1] = b[1] / A[1, 1]\n    for i in 2:n\n        x[i] = (b[i] - dot(A[i, 1:i-1], x[1:i-1])) / A[i, i]\n    end\n    return x\nend\n\n\n\nfunction back_subs(A, b)\n    n = size(A, 1)\n    x = zeros(eltype(b), n)\n    x[end] = b[end] / A[end, end]\n    for i in n-1:-1:1\n        x[i] = (b[i] - dot(A[i, i+1:end], x[i+1:end])) / A[i, i]\n    end\n    return x\nend\n\n\n\nF = lu(A);\nL = F.L;\nU = F.U;\nP = F.P;\n\n\n\nZ = P * b\nW = forw_subs(L,Z)\nV = back_subs(U,W);\n\n\n\nplot(r,[V,V_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"V(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\nCara lain yang biasa dilakukan ketika berhadapan dengan penyelesaian bagian radial dari bentuk simetri bola adalah dengan memperkenalkan fungsi \\phi(r) yang didefinisikan seperti berikut.\\phi(r)=\\frac{V(r)}{r};\\quad\\text{atau}\\quad V(r)=r\\phi(r)\n\nDengan bentuk fungsi tersebut maka persamaan Poisson akan berbentuk berikut.\\frac{1}{r^{2}}\\frac{d}{dr}\\left(r^{2}\\frac{dV(r)}{dr}\\right)=\\frac{1}{r}\\frac{d^2\\phi(r)}{dr^2}=-e^{-r}\n\nUngkapan tersebut dapat dinyatakan dalam bentuk berikut.\\frac{d^2\\phi(r)}{dr^2}=-re^{-r}\n\nPersamaan diferensial di atas akan dapat dinyatakan dalam bentuk persamaan beda hingga yaitu\\left(\\frac{\\phi_{i+1}-2\\phi_i+\\phi_{i-1}}{h^2}\\right)=-r_i e^{-r_i}\n\nUngkapan bagi syarat batas dapat dinyatakan sebagai \\phi_0=0 dan \\phi_{N+1}=2 dimana r_0=0 dan N adalah bilangan bulat positip yang diambil bernilai cukup besar sedemikian hingga r_{N+1}\\rightarrow\\infty.\n\nDengan memperhitungkan nilai pada kedua batas yaitu \\phi_0=0 dan \\phi_{N+1}=2 maka tersebut akan berujud menjadi sejumlah N persamaan simultan yang mengandung N variabel yang perlu dicari yaitu \\left\\{\\phi_1, \\phi_2,\\dots,\\phi_N\\right\\}. Sejumlah N persamaan simultan tersebut dapat ditulis dalam bentuk perkalian matrik sebagaiA\\,\\phi=b\n\nDalam bentuk eksplisit, ungkapan tersebut mengambil bentuk\\left(\n\\begin{array}{cccccc} \n-2&1&0&\\ldots&\\ldots&0\\\\\n1&-2&1&0&\\ldots&0\\\\\n\\vdots&\\vdots&\\ddots&\\vdots&\\vdots&\\vdots\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots&\\vdots\\\\\n\\vdots&\\ldots&0&1&-2&1\\\\\n0&\\ldots&\\ldots&0&1&-2\n\\end{array}\n\\right)\n\\left(\n\\begin{array}{c}\n\\phi_1\\\\\n\\phi_2\\\\\n\\vdots\\\\\n\\vdots\\\\\n\\phi_{N-1}\\\\\n\\phi_N\n\\end{array}\n\\right)=\n\\left(\n\\begin{array}{c}\n-h^2\\,r_1\\,e^{-r_1}-\\phi_0\\\\\n-h^2\\,r_2\\,e^{-r_2}\\\\\n\\vdots\\\\\n\\vdots\\\\\n-h^2\\,r_{N-1}\\,e^{-r_{N-1}}\\\\\n-h^2\\,r_N\\,e^{-r_N}-\\phi_{N+1}\n\\end{array}\n\\right)\n\nBerikut adalah source-code bagi uraian prosedur komputasi tersebut.\n\nrmax = 10.0\nN = 1000\nh = rmax / (N - 1)\nr = collect(range(h, rmax; length=N))\nPhi0 = 0.0\nPhiN1 = 2.0\nPhi_ref = 2.0 .- (2.0 .+ r) .* exp.(-r);\n\n\n\nfunction gen_APhi(N)\n    b1 = ones(N-1)\n    b2 = -2.0 .* ones(N)\n    b3 = ones(N-1)\n    APhi = diagm(1 => b1) + diagm(0 => b2) + diagm(-1 => b3)\n    return APhi\nend\n\n\n\nfunction gen_bPhi(N, h, r, Phi0, PhiN1)\n    bPhi = -h^2 .* r .* exp.(-r)\n    bPhi[1] -= Phi0\n    bPhi[N] -= PhiN1\n    return bPhi\nend\n\n\n\nAPhi=gen_APhi(N)\nbPhi=gen_bPhi(N,h,r,Phi0,PhiN1);\n\n\n\nPhi = APhi \\ bPhi;\n\n\n\nplot(r,[Phi,Phi_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"\\phi(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\nV = Phi ./ r;\n\n\n\nplot(r,V,label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"V(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\n","type":"content","url":"/materi/masalah-syarat-batas-julia#dekomposisi-lu","position":9},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Metode Iterasi Gauss-Seidel"},"type":"lvl2","url":"/materi/masalah-syarat-batas-julia#metode-iterasi-gauss-seidel","position":10},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Metode Iterasi Gauss-Seidel"},"content":"Sebarang matrik persegi A dapat diungkapkan dalam bentuk berikut.A=U+L_D\n\ndenganU=\\begin{pmatrix}\n0&a_{12}&u_{13}&\\cdots&a_{1N}\\\\\n0&0&\\cdots&\\cdots&a_{2N}\\\\\n\\vdots&\\vdots&\\vdots&\\vdots&\\vdots\\\\\n0&0&0&\\cdots&0\n\\end{pmatrix};\\quad\nL_D=\\begin{pmatrix}\na_{11}&0&0&\\cdots&0\\\\\na_{21}&a_{22}\\cdots&\\cdots&0\\\\\n\\vdots&\\vdots&\\vdots&\\vdots&\\vdots\\\\\na_{N1}&a_{N2}&a_{N3}&\\cdots&a_{NN}\n\\end{pmatrix}\n\nDengan demikian penyelesaian persamaan simultan akan berubah menjadiAv=(U+L_D)v=b; \\qquad \\mathrm{menjadi}\\quad v=L_D^{-1}(b-Uv)","type":"content","url":"/materi/masalah-syarat-batas-julia#metode-iterasi-gauss-seidel","position":11},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Penyelesaian berdasar bentuk eksplisit persamaan simultan untuk penentuan V(r)","lvl2":"Metode Iterasi Gauss-Seidel"},"type":"lvl3","url":"/materi/masalah-syarat-batas-julia#penyelesaian-berdasar-bentuk-eksplisit-persamaan-simultan-untuk-penentuan-v-r","position":12},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Penyelesaian berdasar bentuk eksplisit persamaan simultan untuk penentuan V(r)","lvl2":"Metode Iterasi Gauss-Seidel"},"content":"Bentuk persamaan diferensial yang mewakili masalah tersebut dalam koordinat bola pada bagian radial adalahr\\frac{d^2V(r)}{dr^2}+2\\frac{dV(r)}{dr}=-re^{-r}\n\nUngkapan \\textit{source-code} untuk penyelesaian berdasar metode iterasi Gauss-Seidel adalah seperti berikut.\n\nfunction gauss_seidel(A, b, Iter, V_trial)\n    n = length(b)\n    for _ in 1:Iter\n        for i in 1:n\n            s1 = dot(A[i,1:i-1], V_trial[1:i-1])\n            s2 = dot(A[i,i+1:end], V_trial[i+1:end])\n            V_trial[i] = (b[i] - s1 - s2) / A[i,i]\n        end\n    end\n    return V_trial\nend\n\n\n\nrmax = 10.0\nN = 50\nh = rmax / (N - 1)\nr = range(h, stop=rmax, length=N)\nr0 = 0.0\nrN1 = rmax + h\nV0 = 1.0\nVN1 = 2.0 / rN1\nV_ref = 2.0 ./ r .- (2.0 ./ r .+ 1.0) .* exp.(-r);\n\n\n\nA = gen_A(N,r)\nb = gen_b(N,h,r,V0,VN1,r0,rN1);\n\n\n\nIter = 7\n#V_trial = ones(N)\n#V_trial = 1.0 .- 0.08 .* r\nV_trial = 2.0 ./(r .+ 2.0);\n\n\n\nV = gauss_seidel(A,b,Iter,V_trial);\n\n\n\nplot(r,[V, V_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"V(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\nNampak bahwa hingga iterasi ke 7 maka hasil nilai coba untuk\nmasih menyimpang jauh dibanding nilai rujukan. Namun ketika iterasi dinaikkan hingga 900 kali maka nilai coba untuk\nsudah mulai sesuai dan konvergen pada nilai rujukan.\n\nIter = 300;\n#V_trial = ones(N);\n#V_trial = 1.0 .- 0.08 .* r;\nV_trial = 2.0 ./(r .+ 2.0);\n\n\n\nV = gauss_seidel(A,b,Iter,V_trial);\n\n\n\nplot(r,[V, V_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"V(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\n","type":"content","url":"/materi/masalah-syarat-batas-julia#penyelesaian-berdasar-bentuk-eksplisit-persamaan-simultan-untuk-penentuan-v-r","position":13},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Penyelesaian berdasar bentuk eksplisit persamaan simultan untuk penentuan \\phi(r)","lvl2":"Metode Iterasi Gauss-Seidel"},"type":"lvl3","url":"/materi/masalah-syarat-batas-julia#penyelesaian-berdasar-bentuk-eksplisit-persamaan-simultan-untuk-penentuan-phi-r","position":14},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Penyelesaian berdasar bentuk eksplisit persamaan simultan untuk penentuan \\phi(r)","lvl2":"Metode Iterasi Gauss-Seidel"},"content":"Ungkapan persamaan diferensial dapat dinyatakan dalam bentuk berikut.\\frac{d^2\\phi(r)}{dr^2}=-re^{-r}\n\nrmax = 10.0\nN = 50\nh = rmax / (N - 1)\nr = reshape(collect(range(h, stop=rmax, length=N)), N, 1)\nPhi0 = 0.0\nPhiN1 = 2.0\nPhi_ref = 2.0 .- (2.0 .+ r) .* exp.(-r);\n\n\n\nusing Random\n\nIter = 7\n#Phi_trial = 2.0 .* rand(N,1);\nPhi_trial =  ones(N);\n\n\n\nplot(r,Phi_trial,xlabel=L\"r\", ylabel=L\"\\phi_{trial}(r)\", title=\"Fungsi Coba\")\n\n\n\nA = gen_APhi(N)\nb = gen_bPhi(N,h,r,Phi0,PhiN1);\n\n\n\nPhi = gauss_seidel(A,b,Iter,Phi_trial);\n\n\n\nplot(r,[Phi, Phi_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"\\phi(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\nSeperti pada komputasi sebelumnya\n, nampak bahwa hingga iterasi ke 7 maka hasil nilai coba untuk\nmasih menyimpang jauh dibanding nilai rujukan. Namun ketika iterasi dinaikkan hingga 900 kali maka nilai coba untuk\nsudah mulai sesuai dan konvergen pada nilai rujukan.\n\nIter = 800\nPhi_trial = 2.0 .* rand(N,1);\n#Phi_trial =  ones(N);\n\n\n\nA = gen_APhi(N)\nb = gen_bPhi(N,h,r,Phi0,PhiN1);\n\n\n\nPhi = gauss_seidel(A,b,Iter,Phi_trial);\n\n\n\nplot(r,[Phi, Phi_ref],label=[\"Numerik\" \"Analitik\"],xlabel=L\"r\", ylabel=L\"\\phi(r)\", title=\"Penyelesaian Persamaan Poisson\")\n\n\n\n","type":"content","url":"/materi/masalah-syarat-batas-julia#penyelesaian-berdasar-bentuk-eksplisit-persamaan-simultan-untuk-penentuan-phi-r","position":15},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl2","url":"/materi/masalah-syarat-batas-julia#penyelesaian-dalam-ruang-dua-dimensi-2-d","position":16},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"Sebagai gambaran untuk masalah dalam bidang x-y maka diberikan bentuk rapat muatan dengan bentuk berikut\\rho(x,y)=\\epsilon e^{-xy}\n\nTinjau masalah untuk menemukan potensial V(x,y) akibat adanya rapat muatan \\rho(x,y)  pada bidang bentuk persegi panjang di daerah 0\\le x\\le L_x dan 0\\le y\\le L_y sebagai penyelesaian dari persamaan Poisson berikut.\\frac{\\partial^2 V(x,y)}{\\partial x^2}+\\frac{\\partial^2 V(x,y)}{\\partial y^2}=-e^{-xy}\n\nAnggap syarat batas yang harus dipenuhi agar didapatkan penyelesaian yang unik adalah berjenis Derichlet yaitu nilai V(x,y) sepanjang tepi persegi panjang diketahui sebesar V(0,y)=V_0, V(L_x,y)=V_0, V(x,0)=V_0 dan V(x,L_y)=V_0.\n\nMembagi persegi panjang ke dalam N_x\\times N_y buah kisi yang masing-masing kisis memiliki luas h_x\\times h_y sedemikian hingga\\begin{align}\n x_i&=ih_x;\\quad i=0,1,2,\\cdots,N_x \\\\\n y_j&=jh_y;\\quad j=0,1,2,\\cdots,N_y\n\\end{align}\n\nmaka ungkapan beda hingga dari pers~(12) adalah\\frac{V_{i-1,j}-2V_{i,j}+V_{i+1,j}}{h_x^2}+\n\\frac{V_{i,j-1}-2V_{i,j}+V_{i,j+1}}{h_y^2}=-e^{-x_iy_j}\n\nDalam ungkapan di atas, notasi V_{i,j}\\equiv V(x_i, y_j).","type":"content","url":"/materi/masalah-syarat-batas-julia#penyelesaian-dalam-ruang-dua-dimensi-2-d","position":17},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl3","url":"/materi/masalah-syarat-batas-julia#implementasi-syarat-batas","position":18},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"","type":"content","url":"/materi/masalah-syarat-batas-julia#implementasi-syarat-batas","position":19},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl4":"Pada titik-titik bagian dalam bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl4","url":"/materi/masalah-syarat-batas-julia#pada-titik-titik-bagian-dalam-bidang","position":20},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl4":"Pada titik-titik bagian dalam bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"Pada titik-titik kisi yang tidak bersinggungan dengan bagian batas bidang persegi panjang, persamaan tersebut dapat disederhanakan menjadih_y^2 V_{i-1,j}+ h_y^2 V_{i+1,j}-2(h_x^2+h_y^2)V_{i,j}+h_x^2 V_{i,j-1}+h_x^2 V_{i,j+1}=-h_x^2 h_y^2 e^{-x_iy_j}\n\nDalam persamaan di atas, i=2,3,\\cdots,N_x-2 dan  j=2,3,\\cdots,N_y-2.","type":"content","url":"/materi/masalah-syarat-batas-julia#pada-titik-titik-bagian-dalam-bidang","position":21},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl4","url":"/materi/masalah-syarat-batas-julia#pada-titik-titik-bagian-tepi-bidang","position":22},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"Untuk memenuhi syarat batas maka di dekat bidang batas persegi panjang akan terbentuk persamaan berikut.","type":"content","url":"/materi/masalah-syarat-batas-julia#pada-titik-titik-bagian-tepi-bidang","position":23},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi kiri bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-kiri-bidang","position":24},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi kiri bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"h_y^2 V_{2,j}-2(h_x^2+h_y^2)V_{1,j}+h_x^2 V_{1,j-1}+h_x^2V_{1,j+1}=-h_x^2h_y^2 e^{-x_1y_j}-h_y^2 V_{0,j}","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-kiri-bidang","position":25},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi kanan bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-kanan-bidang","position":26},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi kanan bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"\\begin{align}\nh_y^2 V_{N_x-2,j}-2(h_x^2+h_y^2)V_{N_x-1,j}&+h_x^2V_{N_x-1,j-1}+h_x^2V_{N_x-1,j+1}=\\\\\n&-h_x^2h_y^2 e^{-x_{N_x-1}y_j}-h_y^2V_{N_x,j}\n\\end{align}\n\ndengan j=2,3,\\cdots,N_y-2.","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-kanan-bidang","position":27},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi bawah bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-bawah-bidang","position":28},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi bawah bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"h_y^2V_{i-1,1}+h_y^2V_{i+1,1}-2(h_x^2+h_y^2)V_{i,1}+h_x^2V_{i,2}=-h_x^2 h_y^2 e^{-x_i y_1}-h_x^2V_{i,0}","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-bawah-bidang","position":29},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi atas bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-atas-bidang","position":30},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik-titik di tepi atas bidang","lvl4":"Pada titik-titik bagian tepi bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"\\begin{align}\nh_y^2V_{i-1,N_y-1}+h_y^2V_{i+1,N_y-1}-2(h_x^2+h_y^2)V_{i,N_y-1}&+h_x^2V_{i,N_y-12}\n=\\\\\n&-h_x^2 h_y^2 e^{-x_i y_{N_y-1}}-h_x^2V_{i,N_y}\n\\end{align}\n\ndengan i=2,3,\\cdots,N_x-2.","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-titik-di-tepi-atas-bidang","position":31},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl4","url":"/materi/masalah-syarat-batas-julia#pada-empat-titik-di-pojok-bidang","position":32},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"Adapun pada keempat pojok persegi panjang akan memenuhi persamaan berikut.","type":"content","url":"/materi/masalah-syarat-batas-julia#pada-empat-titik-di-pojok-bidang","position":33},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kiri bawah bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kiri-bawah-bidang","position":34},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kiri bawah bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"\\begin{align}\nh_y^2V_{2,1}-2(h_x^2+h_y^2)V_{1,1}+h_x^2V_{1,2}=&-h_x^2 h_y^2 e^{-x_1 y_1}-h_y^2V_{0,1}\\\\\n&-h_x^2V_{1,0}\n\\end{align}","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kiri-bawah-bidang","position":35},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kanan atas bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kanan-atas-bidang","position":36},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kanan atas bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"\\begin{align}\nh_y^2V_{N_x-2,N_y-1}-2(h_x^2+h_y^2)V_{N_x-1,N_y-1}&+h_x^2V_{N_x-1,N_y-2}=-h_x^2 h_y^2 e^{-x_{N_x-1} y_{N_y-1}}\n\\\\\n&-h_y^2V_{N_x,N_y-1}-h_x^2V_{N_x-1,N_y}\n\\end{align}","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kanan-atas-bidang","position":37},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kanan bawah bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kanan-bawah-bidang","position":38},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kanan bawah bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"\\begin{align}\nh_y^2V_{N_x-2,1}-2(h_x^2+h_y^2)V_{N_x-1,1}&+h_x^2V_{N_x-1,2}=-h_x^2 h_y^2 e^{-x_{N_x-1} y_1}\\\\\n&-h_x^2V_{N_x-1,0}-h_y^2V_{N_x,1}\n\\end{align}","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kanan-bawah-bidang","position":39},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kiri atas bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl5","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kiri-atas-bidang","position":40},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl5":"Titik pojok kiri atas bidang","lvl4":"Pada empat titik di pojok bidang","lvl3":"Implementasi Syarat Batas","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"\\begin{align}\nh_y^2V_{2,N_y-1}-2(h_x^2+h_y^2)V_{1,N_y-1}+h_x^2V_{1,N_y-2}=\n&-h_x^2 h_y^2 e^{-x_1 y_{N_y-1}}-h_x^2V_{1,N_y}\\\\\n&-h_y^2V_{0,N_y-1}\n\\end{align}","type":"content","url":"/materi/masalah-syarat-batas-julia#titik-pojok-kiri-atas-bidang","position":41},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Ungkapan Operasi Matrik","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"type":"lvl3","url":"/materi/masalah-syarat-batas-julia#ungkapan-operasi-matrik","position":42},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Poisson","lvl3":"Ungkapan Operasi Matrik","lvl2":"Penyelesaian dalam Ruang Dua Dimensi (2-D)"},"content":"Persamaan-persamaan tersebut dapat disederhanakan ke bentuk operasi matrik apabila diperkenalkan matrik kolom U dengan panjang N_x-1\\times N_y-1 yang berisi gabungan semua baris dari matrik V_{i,j} oleh kaitanU_k=V_{i,j};\\quad\\text{dengan}\\; k=(i-1)(N_y-1)+j-1\n\ndan sebaliknyai=\\text{int}\\left(\\frac{k}{N_y-1}\\right)+1;\\quad\nj=(k)\\,\\text{mod}\\,(N_y-1)+1\n\ndengan \\text{int}(\\dots) berarti bilangan bulat dari operasi pembagian tersebut sedang \\text{mod}(\\dots) adalah sisa dari operasi pembagian.\n\nDengan penggunaan indek k tersebut maka terbentuk seperangkat persamaan simultan yaitu\\begin{align}\n-2(h_x^2+h_y^2)U_1+h_x^2U_2+h_y^2U_{N_y}=&-h_x^2 h_y^2 e^{-x_1 y_1}\\\\\n&-h_y^2V_{0,1}-h_x^2V_{1,0}\\\\\nh_x^2U_1-2(h_x^2+h_y^2)U_2+h_x^2V_3+h_y^2U_{N_y+1}=&-h_x^2 h_y^2 e^{-x_1 y_2}\\\\\n&-h_y^2V_{0,2}\\\\\n\\vdots=&\\vdots\\\\\nh_y^2U_{k-(N_y-1)}+h_x^2U_{k-1} -2(h_x^2+h_y^2)U_k+h_x^2U_{k+1}+h_y^2U_{k+(N_y-1)}=&-h_x^2 h_y^2 e^{-x_i y_j}\\\\\n\\vdots=&\\vdots\n\\end{align}\n\nBentuk tersebut tidak lain adalah bentuk matrikAU=b,\n\ndengan A merupakan matrik pentadiagonal.\n\nxmax = 10.0\nymax = 10.0\nNx = 10\nNy = 10\nN = (Nx - 1) * (Ny - 1)\nhx = xmax / Nx\nhy = ymax / Ny\nx = collect(range(0, stop=xmax, length=Nx + 1))\ny = collect(range(0, stop=ymax, length=Ny + 1))\nV = zeros(Nx + 1, Ny + 1);\n\n\n\nfunction gen_A(Nx, Ny, hx, hy)\n    N = (Nx - 1) * (Ny - 1)\n    A = zeros(N, N)\n\n    for i in 1:Nx-1\n        for j in 1:Ny-1\n            k = (i - 1) * (Ny - 1) + (j - 1)\n\n            if i == 1\n                if j == 1\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+2] = hx^2\n                    A[k+1, k+1 + (Ny - 1)] = hy^2\n                elseif j == Ny - 1\n                    A[k+1, k] = hx^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+1 + (Ny - 1)] = hy^2\n                else\n                    A[k+1, k] = hx^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+2] = hx^2\n                    A[k+1, k+1 + (Ny - 1)] = hy^2\n                end\n            elseif i == Nx - 1\n                if j == 1\n                    A[k+1, k+1 - (Ny - 1)] = hy^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+2] = hx^2\n                elseif j == Ny - 1\n                    A[k+1, k+1 - (Ny - 1)] = hy^2\n                    A[k+1, k] = hx^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                else\n                    A[k+1, k+1 - (Ny - 1)] = hy^2\n                    A[k+1, k] = hx^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+2] = hx^2\n                end\n            else\n                if j == 1\n                    A[k+1, k+1 - (Ny - 1)] = hy^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+2] = hx^2\n                    A[k+1, k+1 + (Ny - 1)] = hy^2\n                elseif j == Ny - 1\n                    A[k+1, k+1 - (Ny - 1)] = hy^2\n                    A[k+1, k] = hx^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+1 + (Ny - 1)] = hy^2\n                else\n                    A[k+1, k+1 - (Ny - 1)] = hy^2\n                    A[k+1, k] = hx^2\n                    A[k+1, k+1] = -2.0 * (hx^2 + hy^2)\n                    A[k+1, k+2] = hx^2\n                    A[k+1, k+1 + (Ny - 1)] = hy^2\n                end\n            end\n        end\n    end\n\n    return A\nend\n\n\n\nA=gen_A(Nx,Ny,hx,hy);\n\n\n\nfunction gen_b(Nx, Ny, hx, hy, x, y, V)\n    N = (Nx - 1) * (Ny - 1)\n    b = zeros(N)\n\n    for i in 1:Nx-1\n        for j in 1:Ny-1\n            k = (i - 1) * (Ny - 1) + (j - 1)\n\n            if i == 1\n                if j == 1\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hy^2 * V[i, j+1] - hx^2 * V[i+1, j]\n                elseif j == Ny - 1\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hy^2 * V[i, j+1] - hx^2 * V[i+1, j+2]\n                else\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hy^2 * V[i, j+1]\n                end\n            elseif i == Nx - 1\n                if j == 1\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hy^2 * V[i+2, j+1] - hx^2 * V[i+1, j]\n                elseif j == Ny - 1\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hy^2 * V[i+2, j+1] - hx^2 * V[i+1, j+2]\n                else\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hy^2 * V[i+2, j+1]\n                end\n            else\n                if j == 1\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hx^2 * V[i+1, j]\n                elseif j == Ny - 1\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1]) - hx^2 * V[i+1, j+2]\n                else\n                    b[k+1] = -hx^2 * hy^2 * exp(-x[i+1] * y[j+1])\n                end\n            end\n        end\n    end\n\n    return b\nend\n\n\n\n\n\nb=gen_b(Nx, Ny, hx, hy, x, y, V);\n\n\n\nusing UnicodePlots\nUnicodePlots.spy(A)\n\n\n\nk = 12\ni = div(k, Ny - 1) + 1\nj = mod(k, Ny - 1) + 1;\n\n\n\ni\n\n\n\nj\n\n\n\nU = A \\ b;\n\n\n\nfor k in 0:N-1\n    i = div(k, Ny - 1) + 1\n    j = mod(k, Ny - 1) + 1\n    V[i, j] = U[k + 1]\nend \n\n\n\nusing Plots\npyplot()  # or use `pyplot()` if you prefer matplotlib-style\n\n# Assuming x, y, and v are already defined\nX = repeat(x', length(y), 1)\nY = repeat(y, 1, length(x))\nZ = V  # v should be a matrix of size (length(y), length(x))\n\n# Create the surface plot\nplot(\n    X, Y, Z,\n    st = :surface,\n    xlabel = \"x\",\n    ylabel = \"y\",\n    zlabel = \"V\",\n    c = :cividis,\n    colorbar = true,\n    size = (800, 700)\n)\n\n","type":"content","url":"/materi/masalah-syarat-batas-julia#ungkapan-operasi-matrik","position":43},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger"},"type":"lvl1","url":"/materi/pers-schrodinger-by-finite-diff-julia","position":0},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger"},"content":"","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia","position":1},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl2":"Implementasi Metode Beda Hingga (Finite Difference)"},"type":"lvl2","url":"/materi/pers-schrodinger-by-finite-diff-julia#implementasi-metode-beda-hingga-finite-difference","position":2},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl2":"Implementasi Metode Beda Hingga (Finite Difference)"},"content":"Pendekatan beda hingga (finte difference) bagi bentuk turunan kedua suatu fungsi pada titik x_i diberikan oleh ungkapan\\left. \\frac{d^2f}{dx^2}\\right]_{x=x_i}\\approx \\frac{f_{i-1}-2f_i+f_{i+1}}{(\\Delta x)^2}\n\ndenganf_i\\equiv f(x_i);\\qquad \\Delta x=x_{i+1}-x_i=\\frac{x_N-x_0}{N};\\qquad x_i=x_0+i\\Delta x; \\qquad i=1,2,3,\\cdots,N\n\nBentuk umum persamaan Schrodinger bagi suatu sistem dengan potensial V(x) disajikan dalam bentuk-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2}+V(x)\\psi(x)=E\\psi(x)\n\nDalam satuan universal, persamaan Schrodinger di atas dapat ditulis dalam bentuk-\\frac{d^2\\psi}{dr^2}+\\gamma(r)\\psi=\\epsilon\\psi\n\nDengan pendekatan beda hingga tersebut maka persamaan Schrodinger pada posisi x_i akan dapat disajikan sebagai ungkapan persamaan beda hingga dalam bentuk-\\left[\\frac{\\psi_{i-1}-2\\psi_i+\\psi_{i+1}}{(\\Delta r)^2}\\right]+\\gamma_i\\psi_i=\\epsilon\\psi_i\n\ndengan \\gamma_i\\equiv \\gamma(r_i) dan \\psi_i\\equiv \\psi(r_i).\n\nDalam ungkapan tersebut, diambil a sebagai faktor skala dalam peubah posisi x sehingga satuan universal dapat dinyatakan dalam bentuk berikutr=\\frac{x}{a};\\qquad \\gamma(r)=\\frac{2ma^2V(x)}{\\hbar^2};\\qquad \\epsilon=\\frac{2ma^2E}{\\hbar^2}\n\nUngkapan tersebut dapat disajikan dalam bentuk lain yaitu-\\psi_{i-1}+\\left[2+(\\Delta r)^2\\gamma_i-(\\Delta r)^2\\epsilon\\right]\\psi_i-\\psi_{i+1}=0\n\nBentuk syarat batas diambil bahwa nilai fungsi gelombang di x_0 dan x_N adalah \\psi_0=0 dan \\psi_N=0. Dengan informasi ini maka persamaan beda hingga yang mewakili persamaan Schrodinger  akan dapat disajikan dalam bentuk matrik yaitu\\begin{pmatrix}\n  2+(\\Delta r)^2\\gamma_1-(\\Delta r)^2\\epsilon & -1 & \\cdots & 0 \\\\\n  -1 & 2+(\\Delta r)^2\\gamma_2-(\\Delta r)^2\\epsilon & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & 0 & \\cdots & 2+(\\Delta r)^2\\gamma_{N-1}-(\\Delta r)^2\\epsilon\n \\end{pmatrix}\\begin{pmatrix}\n  \\psi_1\\\\\n  \\psi_2\\\\\n  \\vdots\\\\\n  \\psi_{N-1}\n \\end{pmatrix}=\\begin{pmatrix}\n  0\\\\\n  0\\\\\n  \\vdots\\\\\n  0\n \\end{pmatrix}","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#implementasi-metode-beda-hingga-finite-difference","position":3},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl2","url":"/materi/pers-schrodinger-by-finite-diff-julia#diagonalisasi-matrik-penyelesaian-masalah-nilai-eigen","position":4},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Bentuk operasi matrik seperti diberikan oleh ungkapan di atas merupakan bentuk masalah nilai eigen dengan nilai eigen adalah \\epsilon dan fungsi eigen diwakili oleh suatu matrik kolom yang memiliki unsur matrik pada baris ke i berupa nilai fungsi gelombang pada posisi x_i yaitu \\psi_i.\n\nTinjau suatu fungsi eigen ke j, yaitu \\psi_j, yang berkaitan dengan nilai eigen (\\Delta r)^2\\epsilon_j dan memenuhi masalah nilai eigen A\\psi_j=(\\Delta r)^2\\epsilon_j\\psi_j dalam bentuk berikut:\\underbrace{\\begin{pmatrix}\n  2+(\\Delta r)^2\\gamma_1 & -1 & \\cdots & 0 \\\\\n  -1 & 2+(\\Delta r)^2\\gamma_2 & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & 0 & \\cdots & 2+(\\Delta r)^2\\gamma_{N-1}\n \\end{pmatrix}}_{A}\n \\underbrace{\\begin{pmatrix}\n  \\psi_{1,j}\\\\\n  \\psi_{2,j}\\\\\n  \\vdots\\\\\n  \\psi_{N-1,j}\n \\end{pmatrix}}_{\\psi_j}=(\\Delta r)^2\\epsilon_j\n  \\underbrace{ \\begin{pmatrix}\n  \\psi_{1,j}\\\\\n  \\psi_{2,j}\\\\\n  \\vdots\\\\\n  \\psi_{N-1,j}\n \\end{pmatrix}}_{\\psi_j}\n\nBerdasar ungkapan matrik tersebut maka dapat ditunjukkan bahwa untuk semua pasangan fungsi eigen \\psi_j dan nilai eigen \\epsilon_j dengan j=1,2\\cdots,N-1 akan berlaku ungkapan matrik berikut.\\begin{align}\n&\\underbrace{\\begin{pmatrix}\n  2+(\\Delta r)^2\\gamma_1 & -1 & \\cdots & 0 \\\\\n  -1 & 2+(\\Delta r)^2\\gamma_2 & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & 0 & \\cdots & 2+(\\Delta r)^2\\gamma_{N-1}\n \\end{pmatrix}}_{A}\n \\underbrace{\\begin{pmatrix}\n  \\psi_{1,1}&\\cdots & \\psi_{1,N-1}\\\\\n  \\psi_{2,1}&\\cdots & \\psi_{2,N-1} \\\\\n  \\vdots &\\ddots & \\vdots\\\\\n  \\psi_{N-1,1}&\\cdots & \\psi_{N-1,N-1} \n \\end{pmatrix}}_{P}=\\nonumber\\\\ \n &\\underbrace{\\begin{pmatrix}\n \\psi_{1,1}&\\cdots & \\psi_{1,N-1}\\\\\n  \\psi_{2,1}&\\cdots & \\psi_{2,N-1} \\\\\n  \\vdots &\\ddots & \\vdots\\\\\n  \\psi_{N-1,1}&\\cdots & \\psi_{N-1,N-1}  \n \\end{pmatrix}}_{P}\n\\underbrace{ \\begin{pmatrix}\n  (\\Delta r)^2\\epsilon_1 & 0 & \\cdots & 0 \\\\\n  0 & (\\Delta r)^2\\epsilon_2 & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & 0 & \\cdots & (\\Delta r)^2\\epsilon_{(N-1)} \\end{pmatrix}}_{D}\n\\end{align}\n\nUngkapan matrik AP=PD dalam persamaan tersebut akan dapat ditulis dalam bentukP^{-1}AP=D\\qquad\\text{atau }\\qquad A=PD P^{-1}\n\nUngkapan seperti diberikan oleh pers (8) disebut sebagai proses diagonalisasi matrik, yaitu suatu proses untuk mengubah sebarang bentuk matrik A ke wakilan matrik diagonal D dan sebaliknya.\n\nDapat dipahami oleh ungkapan matrik yang mewakili persamaan Schrodinger di atas bahwa proses diagonalisasi matrik akan dapat diperoleh apabila nilai-nilai eigen beserta fungsi eigen yang terkait telah tersedia. Nilai-nilai eigen akan digunakan untuk mengisi unsur-unsur diagonal pada matrik diagonal D, sedangkan fungsi-fungsi eigen akan digunakan untuk mengisi tiap kolom pada matrik P.\n\nPemahaman sebaliknya juga berlaku bahwa apabila proses diagonalisasi matrik telah diperoleh maka nilai-nilai eigen beserta fungsi eigen yang terkait akan dapat diperoleh.\n\nDengan kata lain, pencarian masalah nilai eigen serta proses digonalisasi matrik dapat dipahami sebagai proses yang setara.","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#diagonalisasi-matrik-penyelesaian-masalah-nilai-eigen","position":5},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Pencarian nilai eigen untuk matrik tri-diagonal","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl3","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-nilai-eigen-untuk-matrik-tri-diagonal","position":6},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Pencarian nilai eigen untuk matrik tri-diagonal","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Untuk bentuk matrik tri-diagonal seperti diuraikan sebelumnya, proses untuk memperoleh nilai eigen dapat dilakukan dengan prosedur pencarian titik nol, yaitu menjamin agar determinan matrik adalah nol dalam bentuk\\begin{vmatrix}\n  2+(\\Delta r)^2\\gamma_1-(\\Delta r)^2\\epsilon & -1 & \\cdots & 0 \\\\\n  -1 & 2+(\\Delta r)^2\\gamma_2-(\\Delta r)^2\\epsilon & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & 0 & \\cdots & 2+(\\Delta r)^2\\gamma_{N-1}-(\\Delta r)^2\\epsilon\n \\end{vmatrix}=0\n\nDeterminan d_n bagi sebarang bentuk matrik tri-diagonal berorde n disajikan dalam bentuk berikut:d_n=\\begin{vmatrix}\n  a_1 & b_1 & \\cdots & 0 \\\\\n  c_1 & a_2 & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & c_{n-1} & a_n\n \\end{vmatrix}\n\nDapat ditunjukkan bahwa determinan tersebut memiliki sifat yang memenuhi kaitan rekurensi yang melibatkan unsur-unsur matrik a_i, b_i dan c_i dalam bentuk:d_n=a_n d_{n-1}-c_{n-1}b_{n-1}d_{n-2};\\qquad\\text{dengan } n\\text{ adalah orde matrik}\n\nProses rekurensi dapat dimulai dengan nilai awal d_1=a_1 dan d_2=a_1a_2-b_1c_1.\n\nDengan memanfaatkan sifat rekurensi bagi determinan suatu matrik tri-diagonal tersebut maka nilai-nilai eigen akan dapat diperoleh berdasar pencarian titik nol berdasar metode Bisection atau metode Newton-Raphson berdasar ungkapanf(\\epsilon)=d_n(\\epsilon)=0\n\nUntuk sistem kuantum yang sedang ditinjau di atas maka unsur-unsur matrik akan diberikan oleh ungkapan\\begin{align*}\na_i&=2+(\\Delta r)^2\\gamma_i-(\\Delta r)^2\\epsilon;\\quad\\text{untuk}\\quad i=1,2,\\cdots,n\\\\\nb_i&=-1;\\qquad \\text{dan} \\qquad c_i=-1;\\quad{untuk}\\quad i=1,2,\\cdots,(n-1)\n\\end{align*}","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-nilai-eigen-untuk-matrik-tri-diagonal","position":7},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Pencarian fungsi eigen untuk matrik tri-diagonal","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl3","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-fungsi-eigen-untuk-matrik-tri-diagonal","position":8},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Pencarian fungsi eigen untuk matrik tri-diagonal","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Tinjau penyelesaian seperangkat persamaan simultan untuk matrik tri-diagonal dalam bentuk berikut\\begin{pmatrix}\n  a_1 & b_1 & \\cdots & 0 \\\\\n  c_1 & a_2 & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & c_{n-1} & a_n\n \\end{pmatrix}\\begin{pmatrix}\n  x_1 \\\\\n  x_2 \\\\\n  \\vdots  \\\\\n  x_n  \n \\end{pmatrix}=\\begin{pmatrix}\n  y_1 \\\\\n  y_2 \\\\\n  \\vdots  \\\\\n  y_n  \n \\end{pmatrix}\n\nUngkapan tersebut dapat diubah ke bentuk yang setara, dengan menerapkan langkah eliminasi bagi seluruh unsur c_i, sehingga setelah tercapai langkah pengubahan nilai nol bagi unsur c_i maka didapatkan operasi yang melibatkan matrik segitiga atas (upper triangular matrix) dalam bentuk\\begin{pmatrix}\n  a^{'}_1 & b_1 & \\cdots & 0 \\\\\n  0 & a^{'}_2 & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & a^{'}_n\n \\end{pmatrix}\\begin{pmatrix}\n  x_1 \\\\\n  x_2 \\\\\n  \\vdots  \\\\\n  x_n  \n \\end{pmatrix}=\\begin{pmatrix}\n  y^{'}_1 \\\\\n  y^{'}_2 \\\\\n  \\vdots  \\\\\n  y^{'}_n  \n \\end{pmatrix}\n\nDengan bentuk seperangkat persamaan simultan yang setara tersebut maka penyelesaian bagi x_i dapat diperoleh melalui proses substitusi balik.\n\nBerikut merupakan beberapa langkah untuk implementasi penyelesaian seperangkat persamaan simultan bagi matrik tri-diagonal tersebut.","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-fungsi-eigen-untuk-matrik-tri-diagonal","position":9},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl4":"Untuk a^{'}_1=a_1; y^{'}_1=y_1 dan i=2,3,\\cdots,n lakukan","lvl3":"Pencarian fungsi eigen untuk matrik tri-diagonal","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl4","url":"/materi/pers-schrodinger-by-finite-diff-julia#untuk-a-1-a-1-y-1-y-1-dan-i-2-3-cdots-n-lakukan","position":10},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl4":"Untuk a^{'}_1=a_1; y^{'}_1=y_1 dan i=2,3,\\cdots,n lakukan","lvl3":"Pencarian fungsi eigen untuk matrik tri-diagonal","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"\\begin{align*}\n w &= \\frac{c_{i-1}}{a^{'}_{i-1}}\\\\\n a^{'}_i&=a_i - wb_{i-1}\\\\\n y^{'}_i&=y_i - wy^{'}_{i-1}\n\\end{align*}\n\nDengan ungkapan tersebut maka penyelesaian seperangkat persamaan simultan berdasar proses substitusi balik berbentuk\\begin{align}\nx_n&=\\frac{y^{'}_n}{a^{'}_n}\\\\\nx_i&=\\frac{y^{'}_i-b_i x_{i+1}}{a^{'}_i};\\qquad i=(n-1),(n-2),\\dots,1\n\\end{align}\n\nBerdasar langkah di atas maka penyelesaian untuk masalah nilai eigen akan memberikan hasil trivial karena x_i=0 untuk i=1,2,\\cdots,n. Penyelesian tak trivial dapat diatasi dengan tidak mnenyertakan baris atau persamaan ke n sehingga x_n akan bernilai sebarang, dan untuk kemudahan proses komputasi maka sementara dapat dipilih nilai x_n=1. Karena nilai x_i untuk i=(n-1), (n-2), \\cdots,1 merupakan kelipatan dari x_n maka nilai sebarang x_n nantinya dapat ditentukan berdasar syarat normalisir bahwa\\sum_{i=1}^n x_i^2=\\left(x_1^2+x_2^2+\\cdots+1^2\\right)x_n^2=1\\quad\\Longrightarrow\\quad x_n=\\frac{1}{\\sqrt{x_1^2+x_2^2+\\cdots+1^2}}\n\nBerdasar langkah yang dijelaskan di atas maka prosedur untuk memperoleh fungsi gelombang yang merupakan fungsi eigen adalah sebagai berikut:\n\nBerikan nilai eigen yaitu \\epsilon yang terkait dengan fungsi eigen yang akan tentukan.\n\nUntuk memulai proses komputasi, ambil \\psi_{N-1}=1\n\nDengan tidak menyertakan baris ke (N-1) maka seperangkat N-2 persamaan simultan akan berbentuk\\begin{pmatrix}\n  2+(\\Delta r)^2\\gamma_1-(\\Delta r)^2\\epsilon & -1 & \\cdots & 0 \\\\\n  -1 & 2+(\\Delta r)^2\\gamma_2-(\\Delta r)^2\\epsilon & \\cdots & 0\\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & 0 & \\cdots & 2+(\\Delta r)^2\\gamma_{N-2}-(\\Delta r)^2\\epsilon\n \\end{pmatrix}\\begin{pmatrix}\n  \\psi_1\\\\\n  \\psi_2\\\\\n  \\vdots\\\\\n  \\psi_{N-2}\n \\end{pmatrix}=\\begin{pmatrix}\n  0\\\\\n  0\\\\\n  \\vdots\\\\\n  \\psi_{N-1}\n \\end{pmatrix}\n\nSetelah \\psi_1, \\cdots, \\psi_{N-2} diperoleh berdasar langkah untuk implementasi penyelesaian seperangkat persamaan simultan bagi matrik tri-diagonal di atas maka fungsi gelombang ternormalisir yang berpadanan dengan nilai tenaga \\epsilon diperoleh melalui kaitan\\psi_i=\\frac{\\psi_i}{\\sqrt{\\psi_1^2+\\psi_2^2+\\cdots+1^2}};\\qquad i=1,2,\\cdots,(N-1)\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#untuk-a-1-a-1-y-1-y-1-dan-i-2-3-cdots-n-lakukan","position":11},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Sumur Potensial Tak Berhingga","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl3","url":"/materi/pers-schrodinger-by-finite-diff-julia#sumur-potensial-tak-berhingga","position":12},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Sumur Potensial Tak Berhingga","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Untuk sistem sumur potensial tak berhingga maka partikel tidak mampu menerobos dinding sumur sehingga fungsi gelombang hanya berada di dalam sumur. Untuk itu dapat dipilih syarat batas \\psi_0=0 dan \\psi_N=0 masing-masing di r_0=-1 (atau x_0=-a) dan r_N=1 (atau x_N=a). Karena di dalam sumur berlaku V(x)=0 untuk -a<x<a maka diperoleh paramater \\gamma_i=0 untuk i=1,2,\\cdots,N-1. Dengan demikian, unsur-unsur matrik tri-diagonal berbentuk\na_i=2-(\\Delta r)^2\\epsilon untuk i=1,2,\\cdots,N-1 sedangkan b_i=-1 dan c_i=-1 untuk i=1,2,\\cdots,N-2.\n\nTingkat-tingkat tenaga bagi sistem akan dapat diperoleh berdasar kaitanE = \\frac{\\hbar^2 \\epsilon}{2ma^2}; \\qquad \\text{untuk potensial}\\qquad V(r)=\\frac{\\hbar^2 \\gamma(r)}{2ma^2}\n\nImplementasi ungkapan di atas dalam bentuk source-code dapat dilihat seperti di bawah.\n\nusing LinearAlgebra\nusing Plots\nusing LaTeXStrings\n\n# ---- Functions ----\nfunction fung(epsilon, N)\n    dx = 2.0 / N\n    d1 = 2.0 - epsilon * dx^2\n    d2 = (2.0 - epsilon * dx^2)^2 - 1.0\n    b = -1.0\n    c = -1.0\n    a = 2.0 - epsilon * dx^2\n    dn = d2\n    for i in 2:(N-1)             \n        dn = a * d2 - b * c * d1\n        d1, d2 = d2, dn\n    end\n    return dn\nend\n\nfunction eigval_bisec(epsilon1, epsilon2, N)\n    delta = 1e-4\n    ralat = 0.1\n    epsilonm = (epsilon1 + epsilon2) / 2.0\n    while ralat > delta\n        epsilonm = (epsilon1 + epsilon2) / 2.0\n        f1f2 = fung(epsilon1, N) * fung(epsilonm, N)\n        if f1f2 < 0.0\n            epsilon2 = epsilonm\n        else\n            epsilon1 = epsilonm\n        end\n        ralat = abs((epsilon2 - epsilon1) / epsilon2)\n    end\n    return epsilonm\nend\n\nfunction eigvec_tridiag(epsilon, N)\n    dx = 2.0 / N\n    a = 2.0 - epsilon * dx^2\n    b = -1.0\n    c = -1.0\n\n    d = fill(a, N-2)              # main diagonal\n    e = fill(-1.0, N-3)           # subdiagonal (also superdiagonal)\n    f = zeros(N-2)                # RHS\n    f[end] = 1.0\n\n    # Forward elimination (Thomas algorithm for tridiagonal)\n    for i in 2:(N-2)              # Python: range(2, N-1)\n        m = e[i-1] / d[i-1]\n        d[i] -= m * b\n        f[i] -= m * f[i-1]\n    end\n\n    # Back substitution\n    v = zeros(N-1)\n    v[N-2] = f[N-2] / d[N-2]\n    v[N-1] = 1.0\n    s = v[N-1]^2 + v[N-2]^2\n    for i in (N-3):-1:1           # Python: range(N-4, -1, -1)\n        v[i] = (f[i] - b * v[i+1]) / d[i]\n        s += v[i]^2\n    end\n\n    v ./= sqrt(s)                 # normalize\n    return v\nend\n\n\n\n# ---- Parameters & evaluation ----\nN = 500\nm = 100\nepsilon_vals = range(1.0, 10.0, length=m)\nfe = [fung(ε, N) for ε in epsilon_vals];\n\n\n\n\nplot(epsilon_vals, fe;\n     xlabel=L\"\\epsilon\",\n     ylabel=L\"f(\\epsilon)\",\n     title=\"Fungsi untuk Tenaga\",\n     grid=true, gridstyle=:solid)\n\n\n\n\n# ---- Root via bisection ----\nepsilon_root = eigval_bisec(2.0, 4.0, N)\nprintln(epsilon_root)\n\n\n\n\n# ---- Eigenvector and plot ----\ny = range(-1.0, 1.0, length=N-1)\nv = eigvec_tridiag(epsilon_root, N);\n\n\n\n\nplot(y, v;\n     xlabel=L\"y\",\n     ylabel=L\"\\psi(y)\",\n     title=\"Fungsi Gelombang\",\n     grid=true, gridstyle=:solid)\n\n\n\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#sumur-potensial-tak-berhingga","position":13},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Sumur Potensial Berhingga","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl3","url":"/materi/pers-schrodinger-by-finite-diff-julia#sumur-potensial-berhingga","position":14},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Sumur Potensial Berhingga","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Untuk sistem sumur potensial berhingga maka partikel mampu menerobos dinding sumur sehingga fungsi gelombang tidak hanya berada di dalam sumur. Untuk itu perlu dijamin agar syarat batas \\psi_0=0 dan \\psi_N=0 dapat terpenuhi pada posisi r_0  dan r_N. Karena kedua posisi batas tersebut belum diketahui, maka dapat dicoba pada berbagai posisi yang jauh dari dinding sumur. Berdasarkan intuisi maka dapat diperkirakan bahwa terobosan kuantum akan semakin terasa ketika tenaga sistem besar. Sebagai contoh, untuk tenaga dasar (ground-state) maka dapat dicoba pada posisi x_0\\approx -1.2 dan x_N\\approx 1.2 dan kemudian untuk tenaga eksitasi pertama maka dapat dicoba pada posisi x_0\\approx -1.6 dan x_N\\approx 1.6.\n\nBerbeda dengan sistem sumur potensial tak berhingga yang memiliki nilai \\gamma_i=0 untuk i=1,2,\\cdots,N, untuk sistem sumur potensial berhingga berlaku\\begin{align}\n\\gamma(r)&=\\frac{2ma^2V_0}{\\hbar^2}=\\gamma;&-\\infty<r<-1\\nonumber\\\\\n&=0;&-1<r<1\\nonumber\\\\\n&=\\frac{2ma^2V_0}{\\hbar^2}=\\gamma;&1<r<\\infty\n\\end{align}\n\nDengan demikian, unsur-unsur matrik tri-diagonal berbentuk\na_i=2+(\\Delta r)^2\\gamma_i-(\\Delta r)^2\\epsilon untuk i=1,2,\\cdots,N-1 sedangkan b_i=-1 dan c_i=-1 untuk i=1,2,\\cdots,N-2.\n\nTingkat-tingkat tenaga bagi sistem akan dapat diperoleh berdasar kaitanE = \\frac{\\hbar^2 \\epsilon}{2ma^2}; \\qquad \\text{untuk potensial}\\qquad V(r)=\\frac{\\hbar^2 \\gamma(r)}{2ma^2}\n\nImplementasi ungkapan di atas dalam bentuk source-code dapat dilihat seperti di bawah.\n\nfunction observ(v0, rmak, rmin, dr, N)\n    r = zeros(N-1)\n    gamma = zeros(N-1)\n    for i in 1:(N-1)\n        r[i] = dr * i + rmin\n        if r[i] <= -1.0 || r[i] >= 1.0\n            gamma[i] = v0\n        else\n            gamma[i] = 0.0\n        end\n    end\n    return r, gamma\nend\n\n\n\nfunction fung_gamma(epsilon, dr, gamma, N)\n    a = zeros(N-1)\n    b = zeros(N-2)\n    c = zeros(N-2)\n    for i in 1:(N-1)\n        a[i] = 2.0 + gamma[i] * dr^2 - epsilon * dr^2\n    end\n    for i in 1:(N-2)\n        b[i] = -1.0\n        c[i] = -1.0\n    end\n    d1 = a[1]\n    d2 = a[2] * d1 - b[1] * c[1]\n    dn = 0.0\n    for i in 3:(N-1)            \n        dn = a[i] * d2 - b[i-1] * c[i-1] * d1\n        d1, d2 = d2, dn\n    end\n    return dn\nend\n\n\n\nfunction eigval_bisec(epsilon1, epsilon2, dr, gamma, N)\n    delta = 1e-4\n    ralat = 0.1\n    epsilonm = (epsilon1 + epsilon2) / 2.0\n    while ralat > delta\n        epsilonm = (epsilon1 + epsilon2) / 2.0\n        f1f2 = fung_gamma(epsilon1, dr, gamma, N) * fung_gamma(epsilonm, dr, gamma, N)\n        if f1f2 < 0.0\n            epsilon2 = epsilonm\n        else\n            epsilon1 = epsilonm\n        end\n        ralat = abs((epsilon2 - epsilon1) / epsilon2)\n    end\n    return epsilonm\nend\n\n\n\n\nfunction eigvec_tridiag(epsilon, dr, gamma, N)\n    d = zeros(N-2)\n    e = zeros(N-3)\n    b = zeros(N-3)\n    for i in 1:(N-2)\n        d[i] = 2.0 + gamma[i] * dr^2 - epsilon * dr^2\n    end\n    for i in 1:(N-3)\n        e[i] = -1.0\n        b[i] = -1.0\n    end\n    f = zeros(N-2)            \n    f[end] = 1.0\n\n    # Forward elimination (Thomas algorithm for tridiagonal)\n    for i in 2:(N-2)             \n        m = e[i-1] / d[i-1]\n        d[i] -= m * b[i-1]\n        f[i] -= m * f[i-1]\n    end\n\n    # Back substitution\n    v = zeros(N-1)\n    v[N-2] = f[N-2] / d[N-2]\n    v[N-1] = 1.0\n    s = v[N-1]^2 + v[N-2]^2\n    for i in (N-3):-1:1         \n        v[i] = (f[i] - b[i] * v[i+1]) / d[i]\n        s += v[i]^2\n    end\n\n    v ./= sqrt(s)                 # normalize\n    return v\nend\n\n\n\n# ---- Parameters & evaluation ----\nN = 500\nm = 100\nrmak = 1.2\nrmin = -rmak\ndr = (rmak - rmin) / N\nv0 = 50.0\nr = zeros(N-1)\ngamma = zeros(N-1)\nr, gamma = observ(v0, rmak, rmin, dr, N)\nepsilon = range(1.0, 10.0, length=m)\nfe = zeros(m)\nfor i in 1:m\n    fe[i] = fung_gamma(epsilon[i], dr, gamma, N)\nend\n\n\n\nplot(r, gamma;\n     xlabel=L\"r\",\n     ylabel=L\"\\gamma\",\n     title=\"Potensial\",\n     grid=true, gridstyle=:solid)\n\n\n\n\nplot(epsilon, fe;\n     xlabel=L\"\\epsilon\",\n     ylabel=L\"f(\\epsilon)\",\n     title=\"Fungsi untuk Tenaga\",\n     grid=true, gridstyle=:solid)\n\n\n\n\n# ---- Root via bisection ----\nepsilon = eigval_bisec(7.0, 8.0, dr, gamma, N)\nprintln(epsilon)\n\n\n\n\n# ---- Eigenvector and plot ----\nv = eigvec_tridiag(epsilon, dr, gamma, N);\nvabs = v .^ 2;\n\n\n\n\nplot(r, vabs;\n     xlabel=L\"y\",\n     ylabel=L\"\\psi(y)\",\n     title=\"Fungsi Gelombang\",\n     grid=true, gridstyle=:solid)\n\n\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#sumur-potensial-berhingga","position":15},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Sumur Bertanggul Potensial","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl3","url":"/materi/pers-schrodinger-by-finite-diff-julia#sumur-bertanggul-potensial","position":16},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Sumur Bertanggul Potensial","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Mirip seperti sistem sumur potensial berhingga di atas maka untuk sistem dengan potensial berbentuk sumur bertanggul maka partikel mampu menerobos dinding sumur sehingga fungsi gelombang tidak hanya berada di dalam sumur. Sebagai tambahan maka partikel di dalam sumur juga berpotensi mengalami terobosan kuantum saat mengenai tanggul potensial.\n\nDengan melakukan modifikasi pada sistem sumur potensial berhingga, untuk sistem dengan potensial berbentuk sumur bertanggul berlaku\\begin{align}\n\\gamma(r)&=\\frac{2ma^2V_0}{\\hbar^2}=\\gamma;&-\\infty<r<0\\nonumber\\\\\n&=0;&0<r<\\rho\\nonumber\\\\\n&=\\frac{2ma^2V_1}{\\hbar^2}=\\beta;&\\rho<r<1\\nonumber\\\\\n&=\\frac{2ma^2V_0}{\\hbar^2}=\\gamma;&1<r<\\infty\n\\end{align}\n\nDalam ungkapan digunakan satuan universal seperti berikutr=\\frac{x}{a};\\qquad\\rho=\\frac{b}{a};\\qquad\\epsilon=\\frac{2ma^2E}{\\hbar^2};\\qquad\\gamma=\\frac{2ma^2V_0}{\\hbar^2};\\qquad\\beta=\\frac{2ma^2V_1}{\\hbar^2}\n\nDengan demikian, unsur-unsur matrik tri-diagonal berbentuk\na_i=2+(\\Delta r)^2\\gamma_i-(\\Delta r)^2\\epsilon untuk i=1,2,\\cdots,N-1 sedangkan b_i=-1 dan c_i=-1 untuk i=1,2,\\cdots,N-2.\n\nTingkat-tingkat tenaga bagi sistem akan dapat diperoleh berdasar kaitanE = \\frac{\\hbar^2 \\epsilon}{2ma^2}; \\qquad \\text{untuk potensial}\\qquad V(r)=\\frac{\\hbar^2 \\gamma(r)}{2ma^2}\n\nImplementasi ungkapan di atas dalam bentuk source-code dapat dilihat seperti di bawah.\n\nfunction observ1(v0, v1, rmak, rmin, dr, rho, N)\n    r = zeros(N-1)\n    gamma = zeros(N-1)\n    beta = zeros(N-1)\n    for i in 1:(N-1)\n        r[i] = dr * i + rmin\n        if r[i] <= 0.0 || r[i] >= 1.0\n            gamma[i] = v0\n        elseif r[i] <= rho\n            gamma[i] = 0.0\n        else\n            gamma[i] = v1\n        end\n    end\n    return r, gamma\nend\n\n\n\nfunction fung_gamma1(epsilon, dr, gamma, N)\n    a = zeros(N-1)\n    b = zeros(N-2)\n    c = zeros(N-2)\n    for i in 1:(N-1)\n        a[i] = 2.0 + gamma[i] * dr^2 - epsilon * dr^2\n    end\n    for i in 1:(N-2)\n        b[i] = -1.0\n        c[i] = -1.0\n    end\n    d1 = a[1]\n    d2 = a[2] * d1 - b[1] * c[1]\n    dn = 0.0\n    for i in 3:(N-1)            \n        dn = a[i] * d2 - b[i-1] * c[i-1] * d1\n        d1, d2 = d2, dn\n    end\n    return dn\nend\n\n\n\nfunction eigval_bisec1(epsilon1, epsilon2, dr, gamma, N)\n    delta = 1e-4\n    ralat = 0.1\n    epsilonm = (epsilon1 + epsilon2) / 2.0\n    while ralat > delta\n        epsilonm = (epsilon1 + epsilon2) / 2.0\n        f1f2 = fung_gamma1(epsilon1, dr, gamma, N) * fung_gamma1(epsilonm, dr, gamma, N)\n        if f1f2 < 0.0\n            epsilon2 = epsilonm\n        else\n            epsilon1 = epsilonm\n        end\n        ralat = abs((epsilon2 - epsilon1) / epsilon2)\n    end\n    return epsilonm\nend\n\n\n\nfunction eigvec_tridiag1(epsilon, dr, gamma, N)\n    d = zeros(N-2)\n    e = zeros(N-3)\n    b = zeros(N-3)\n    for i in 1:(N-2)\n        d[i] = 2.0 + gamma[i] * dr^2 - epsilon * dr^2\n    end\n    for i in 1:(N-3)\n        e[i] = -1.0\n        b[i] = -1.0\n    end\n    f = zeros(N-2)            \n    f[end] = 1.0\n\n    # Forward elimination (Thomas algorithm for tridiagonal)\n    for i in 2:(N-2)             \n        m = e[i-1] / d[i-1]\n        d[i] -= m * b[i-1]\n        f[i] -= m * f[i-1]\n    end\n\n    # Back substitution\n    v = zeros(N-1)\n    v[N-2] = f[N-2] / d[N-2]\n    v[N-1] = 1.0\n    s = v[N-1]^2 + v[N-2]^2\n    for i in (N-3):-1:1         \n        v[i] = (f[i] - b[i] * v[i+1]) / d[i]\n        s += v[i]^2\n    end\n\n    v ./= sqrt(s)                 # normalize\n    return v\nend\n\n\n\n# ---- Parameters & evaluation ----\nN = 500\nm = 100\nrmak = 1.2\nrmin = -0.4\ndr = (rmak - rmin) / N\nv0 = 100.0\nv1 = 25.0\nrho = 0.5\nr = zeros(N-1)\ngamma = zeros(N-1)\nr, gamma = observ1(v0, v1, rmak, rmin, dr, rho, N)\nepsilon = range(12.0, 20.0, length=m)\nfe = zeros(m)\nfor i in 1:m\n    fe[i] = fung_gamma1(epsilon[i], dr, gamma, N)\nend\n\n\n\nplot(r, gamma;\n     xlabel=L\"r\",\n     ylabel=L\"\\gamma\",\n     title=\"Potensial\",\n     grid=true, gridstyle=:solid)\n\n\n\n\nplot(epsilon, fe;\n     xlabel=L\"\\epsilon\",\n     ylabel=L\"f(\\epsilon)\",\n     title=\"Fungsi untuk Tenaga\",\n     grid=true, gridstyle=:solid)\n\n\n\n\n# ---- Root via bisection ----\nepsilon = eigval_bisec1(14.0, 15.0, dr, gamma, N)\nprintln(epsilon)\n\n\n\n# ---- Eigenvector and plot ----\nv = eigvec_tridiag1(epsilon, dr, gamma, N);\nvabs = v .^ 2;\n\n\n\nplot(r, vabs;\n     xlabel=L\"y\",\n     ylabel=L\"\\psi(y)\",\n     title=\"Fungsi Gelombang\",\n     grid=true, gridstyle=:solid)\n\n\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#sumur-bertanggul-potensial","position":17},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Pencarian nilai eigen dan fungsi eigen untuk sebarang bentuk matrik","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl3","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-nilai-eigen-dan-fungsi-eigen-untuk-sebarang-bentuk-matrik","position":18},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl3":"Pencarian nilai eigen dan fungsi eigen untuk sebarang bentuk matrik","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Apabila masalah nilai eigen bukan berbentuk matrik tri-diagonal maka cara komputasi yang cukup efektif di atas menjadi tidak dimungkinkan. Untuk keadaan ini maka pencarian nilai eigen dan fungsi eigen perlu diselesaikan dengan metode lain yang berlaku untuk matrik dengan bentuk sebarang, salah satu diantaranya adalah dengan implementasi metode dekomposisi LU. Istilah LU merupakan singkatan dari (Lower Triangular Matrix) untuk L dan  (Upper Triangular Matrix) untuk U. Seperti yang tersirat dari nama tersebut maka prinsip dasar dari metode pemisahan LU adalah mengubah sebarang matrik A menjadi produk perkalian matrik segitiga bawah L dan matrik segitiga atas U yaitu A=LU sehingga dapat memanfaatkan proses substitusi maju bagi matrik L dan substitusi balik bagi matrik U ketika nantinya dimanfaatkan untuk mendapatkan penyelesaian x.A=LU\n\nApabila bentuk matrik U diambil sama dengan matrik segitiga atas A^{'} yang diperoleh dari proses eliminasi Gauss maka berlaku ungkapan berikut.U=\\begin{pmatrix}\nu_{11}&u_{12}&u_{13}&\\cdots&u_{1N}\\\\\n0&u_{22}&u_{22}&\\cdots&u_{2N}\\\\\n0&0&u_{33}&\\cdots&u_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&u_{NN}\n\\end{pmatrix}=\\begin{pmatrix}\na^{'}_{11}&a^{'}_{12}&a^{'}_{13}&\\cdots&a^{'}_{1N}\\\\\n0&a^{'}_{22}&a^{'}_{23}&\\cdots&a^{'}_{2N}\\\\\n0&0&a^{'}_{33}&\\cdots&a^{'}_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&a^{'}_{NN}\n\\end{pmatrix}=A^{'}\n\nDengan bentuk matrik segitiga atas U tersebut maka bentuk matrik segitiga bawah dapat ditentukan berdasar operasi berikut.\\begin{align}\nLU&=\\begin{pmatrix}\n1&0&0&\\cdots&0\\\\\nl_{21}&1&0&\\cdots&0\\\\\nl_{31}&l_{32}&1&\\cdots&0\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\nl_{N1}&l_{N2}&l_{N3}&\\cdots&1\n\\end{pmatrix}\n\\begin{pmatrix}\na^{'}_{11}&a^{'}_{12}&a^{'}_{13}&\\cdots&a^{'}_{1N}\\\\\n0&a^{'}_{22}&a^{'}_{23}&\\cdots&a^{'}_{2N}\\\\\n0&0&a^{'}_{33}&\\cdots&a^{'}_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&a^{'}_{NN}\n\\end{pmatrix}\\nonumber\\\\\n&=\\begin{pmatrix}\na^{'}_{11}&a^{'}_{12}&a^{'}_{13}&\\cdots&a^{'}_{1N}\\\\\nl_{21}a^{'}_{11}&a^{'}_{22}&a^{'}_{23}&\\cdots&a^{'}_{2N}\\\\\nl_{31}a^{'}_{11}&l_{32}a^{'}_{22}&a^{'}_{33}&\\cdots&a^{'}_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\nl_{N1}a^{'}_{11}&l_{N2}a^{'}_{22}&l_{N3}a^{'}_{33}&\\cdots&a^{'}_{NN}\n\\end{pmatrix}\n=\\begin{pmatrix}\na_{11}&a_{12}&a_{13}&\\cdots&a_{1N}\\\\\na_{21}&a_{22}&a_{23}&\\cdots&a_{2N}\\\\\na_{31}&a_{32}&a_{33}&\\cdots&a_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\na_{N1}&a_{N2}&a_{N3}&\\cdots&a_{NN}\n\\end{pmatrix}=A\n\\end{align}\n\nBerdasar ungkapan tersebut maka bentuk matrik segitiga bawah L adalah seperti berikut.L=\\begin{pmatrix}\n1&0&0&\\cdots&0\\\\\nl_{21}&1&0&\\cdots&0\\\\\nl_{31}&l_{32}&1&\\cdots&0\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\nl_{N1}&l_{N2}&l_{N3}&\\cdots&1\n\\end{pmatrix}=\\begin{pmatrix}\n1&0&0&\\cdots&0\\\\\n\\frac{a_{21}}{a^{'}_{11}}&1&0&\\cdots&0\\\\\n\\frac{a_{31}}{a^{'}_{11}}&\\frac{a_{32}}{a^{'}_{22}}&1&\\cdots&0\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n\\frac{a_{N1}}{a^{'}_{11}}&\\frac{a_{N2}}{a^{'}_{22}}&\\frac{a_{N3}}{a^{'}_{33}}&\\cdots&1\n\\end{pmatrix}\n\nDari bentuk matrik segitiga bawah L tersebut maka menjadi jelas bahwa unsur matrik bagi L tidak lain merupakan faktor pengali dalam metode eliminasi Gauss dalam proses pengubahan ke nilai nol pada kolom ke k dan baris ke i yaitu l_{ik}=\\frac{a_{ik}}{a^{'}_{kk}}=\\frac{U_{ik}}{U_{kk}}.\n\nBerikut merupakan source-code bagi implementasi metode pemisahan LU.\n\nfunction lu_decomp(A)\n    N = size(A, 1)\n    L = Matrix{Float64}(I, N, N)\n    U = copy(A)\n    for k in 1:N-1\n        for i in k+1:N\n            pengali = U[i, k]/U[k, k]\n            L[i, k] = pengali\n            U[i, k:N] -= pengali*U[k, k:N];\n        end\n    end\n\n    return L, U \nend\n\n\n\nfunction deter(A)\n    determinan = 0.0\n    N = size(A, 1)\n    L, U = lu_decomp(A)\n    sum = 1.0\n    for i in 1:N\n        sum *= U[i,i]\n    end\n\n    determinan = sum\n    return determinan\nend    \n\n\n\nfunction back_subs(U::Matrix{Float64},w::Vector{Float64})\n    N = size(U,1)\n    x = zeros(Float64,N)\n    x[N] = w[N]/U[N,N]\n    for i in N-1:-1:1\n        sum = 0\n        for j in i+1:N\n            sum += U[i, j]*x[j]\n        end    \n        x[i] = (w[i]-sum)/U[i, i]    \n    end\n    \n    return x\nend\n\n\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-nilai-eigen-dan-fungsi-eigen-untuk-sebarang-bentuk-matrik","position":19},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl4":"Pencarian nilai eigen untuk sebarang bentuk matrik","lvl3":"Pencarian nilai eigen dan fungsi eigen untuk sebarang bentuk matrik","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl4","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-nilai-eigen-untuk-sebarang-bentuk-matrik","position":20},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl4":"Pencarian nilai eigen untuk sebarang bentuk matrik","lvl3":"Pencarian nilai eigen dan fungsi eigen untuk sebarang bentuk matrik","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Ditinjau suatu masalah nilai eigen yang dapat dinyatakan dengan bentuk ungkapan  berikut.Ax=\\lambda x\n\nSeperti sudah dijelaskan dalam uraian untuk matrik tri-diagonal sebelumnya, dalam persamaan nilai eigen  tersebut maka A merupakan matrik bujursangkar berorde N\\times N yang sudah diketahui. Matrik kolom x merupakan matrik yang akan diselesaikan dan biasa disebut sebagai fungsi eigen. Adapun \\lambda adalah suatu nilai yang juga akan diselesaikan dan biasa disebut sebagai nilai eigen.\n\nPersamaan nilai eigen  dapat diubah ke ungkapan persamaan simultan berupa persamaan homogen, yaitu ruas kanan persamaan adalah matrik O dalam bentuk berikut.(A-\\lambda I)x=O \\implies x=(A-\\lambda I)^{-1}0=\\frac{1}{\\det{(A-\\lambda I)}}\\text{adj}(A-\\lambda I)\\,O\n\nDalam ungkapan di atas, matrik I melambangkan matrik identitas yang memiliki norde sama dengan matrik A sedangkan matrik O merupakan matrik kolom dengan semua unsur bernilai 0.\n\nUpaya untuk menyelesaikan bentuk persamaan homogen tersebut dengan beberapa metode penyelesaian persamaan simultan yang dijelaskan dalam uraian sebelumnya nampak akan gagal karena akan memberikan penyelesaian trivial berupa fungsi eigen x=O. Untuk mendapatkan penyelesaian tak trivial sedemikian hingga fungsi eigen x\\ne O, beserta nilai eigen \\lambda yang terkait dengan fungsi eigen tersebut, maka dapat digunakan mekanisme yang disebut proses diagonalisasi matrik.\n\nBerdasar pada ungkapan persamaan homogen di atas maka proses diagonalisasi matrik pada dasarnya merupakan suatu upaya agar x\\ne O atau x\\propto \\frac{O}{0}, yang dapat terpenuhi apabila dipersyaratkan bentuk berikut.\\det(A-\\lambda I)=\\begin{vmatrix}\na_{11}-\\lambda&a_{12}&a_{13}&\\cdots&a_{1N}\\\\\na_{21}&a_{22}-\\lambda&a_{23}&\\cdots&a_{2N}\\\\\na_{31}&a_{32}&a_{33}-\\lambda&\\cdots&a_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\na_{N1}&a_{N2}&a_{N3}&\\cdots&a_{NN}-\\lambda\n\\end{vmatrix}=0\n\nUngkapan di atas tidak lain merupakan bentuk masalah pencarian akar atau titik nol suatu fungsi f(\\lambda)=\\det(A-\\lambda I), yaitu nilai eigen \\lambda merupakan akar atau titik nol fungsi tersebut. Dengan demikian nilai eigen akan dapat diperoleh menggunakan metode pencarian akar sebagai contoh metode Bisection atau metode Newton-Raphson.\n\nAndaikan bentuk matrik di atas berupa matrik diagonal atau matrik segitiga dengan bentuk berikut:f(\\lambda)=\\det(A-\\lambda I)=\\begin{vmatrix}\na_{11}-\\lambda&a_{12}&a_{13}&\\cdots&a_{1N}\\\\\n0&a_{22}-\\lambda&a_{23}&\\cdots&a_{2N}\\\\\n0&0&a_{33}-\\lambda&\\cdots&a_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&a_{NN}-\\lambda\n\\end{vmatrix}=0\n\nDengan bentuk tersebut maka penyelesaian akan mudah diperoleh yaitu:f(\\lambda)=\\det(A-\\lambda I)=\\left(a_{11}-\\lambda\\right)\\left(a_{22}-\\lambda\\right)\\cdots \\left(a_{NN}-\\lambda\\right)=0\n\nDengan demikian penyelesaian nilai eigen \\lambda diperoleh sebagai berikut:\\lambda_1=a_{11};\\quad \\lambda_2=a_{22};\\quad \\cdots \\quad\\lambda_N=a_{NN}\n\nIstilah proses diagonalisasi matrik untuk memperoleh penyelesaian tak trivial sedemikian hingga fungsi eigen x\\ne O, beserta nilai eigen \\lambda yang terkait dengan fungsi eigen tersebut, menjadi mudah dipahami dari ungkapan matrik di atas.\n\nSecara umum untuk matrik tidak diagonal A maka proses untuk memperoleh nilai eigen \\lambda dapat dilakukan dengan tahap berikut:\n\nBerikan nilai coba bagi nilai eigen \\lambda sebagai masukan bagi nilai coba akar.\n\nLakukan proses diagonalisasi matrik dengan metode dekomposisi LU, yaitu (A-\\lambda I)=LU untuk memperoleh fungsi f(\\lambda)=\\det(A-\\lambda I).\n\nTentukan nilai eigen melalui proses pencarian akar bagi ungkapan f(\\lambda)=\\det(A-\\lambda I)=0 menggunakan metode\nBisection.\n\nBerikut merupakan source-code bagi implementasi percarian nilai eigen \\lambda berdasar tahapan di atas.\n\nfunction matrix_A(dr, gamma, N)\n    a = zeros(N-1)\n    b = zeros(N-2)\n    c = zeros(N-2)\n    A = zeros(N-1, N-1)\n    for i in 1:(N-1)\n        a[i] = 2.0 + gamma[i] * dr^2\n    end\n    for i in 1:(N-2)\n        b[i] = -1.0\n        c[i] = -1.0\n    end\n    A = diagm(0 => a, -1 => b, 1 => c)\n    return A\nend\n\n\n\nfunction fung_lambda(A, dr, epsilon)\n    N = size(A, 1)\n    A_lambda = A .- epsilon * dr^2 * I(N)\n    hasil = 0.0\n    hasil = deter(A_lambda)\n\n    return hasil\nend   \n\n\n\nfunction nil_eigen(A, epsilon1, epsilon2)\n    N = size(A, 1)\n    U = zeros(N,N)\n    a = epsilon1\n    b = epsilon2\n    c = 0.0\n    iter = 0\n    while (b - a)/2 > 1.0e-6 && iter < 100\n        iter += 1\n        c = (a + b)/2\n        f1 = fung_lambda(A, dr, a)\n        f2 = fung_lambda(A, dr, c)       \n        if f1 * f2 < 0\n            b = c\n        else\n            a = c\n        end\n    end\n\n    return c\nend\n\n\n\n# ---- Parameters & evaluation ----\nN = 500\nm = 25\nrmak = 1.2\nrmin = -0.4\ndr = (rmak - rmin) / N\nv0 = 100.0\nv1 = 25.0\nrho = 0.5\nr = zeros(N-1)\ngamma = zeros(N-1);\n\n\n\nr, gamma = observ1(v0, v1, rmak, rmin, dr, rho, N)\nA = matrix_A(dr, gamma, N)\nepsilon = range(12.0, 20.0, length=m)\nfe = zeros(m)\nfor i in 1:m\n    fe[i] = fung_lambda(A, dr, epsilon[i])\nend\n\n\n\nplot(epsilon, fe;\n     xlabel=L\"\\epsilon\",\n     ylabel=L\"f(\\epsilon)\",\n     title=\"Fungsi untuk Tenaga\",\n     grid=true, gridstyle=:solid)\n\n\n\n\nepsilon1 = 12.0\nepsilon2 = 15.0\nepsilon_new = nil_eigen(A, epsilon1, epsilon2)\n\n\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-nilai-eigen-untuk-sebarang-bentuk-matrik","position":21},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl4":"Pencarian fungsi eigen untuk sebarang bentuk matrik","lvl3":"Pencarian nilai eigen dan fungsi eigen untuk sebarang bentuk matrik","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"type":"lvl4","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-fungsi-eigen-untuk-sebarang-bentuk-matrik","position":22},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Schrodinger","lvl4":"Pencarian fungsi eigen untuk sebarang bentuk matrik","lvl3":"Pencarian nilai eigen dan fungsi eigen untuk sebarang bentuk matrik","lvl2":"Diagonalisasi Matrik: Penyelesaian Masalah Nilai Eigen"},"content":"Ketika nilai eigen \\lambda tertentu telah diperoleh berdasar prosedur pencarian nilai eigen di atas maka fungsi eigen yang berpadanan dengan nilai eigen tertentu tersebut akan dapat diperoleh dengan cara memasukkan kembali nilai eigen \\lambda ke persamaan nilai eigen semula. Pada satu nilai eigen \\lambda tertentu ini, penggunaan metode dekomposisi LU dalam proses diagonalisasi matrik \\det(A-\\lambda I)=0 menyebabkan berlakunya kaitan berikut.\\det(A-\\lambda I)=\\begin{vmatrix}\na_{11}-\\lambda&a_{12}&a_{13}&\\cdots&a_{1N}\\\\\n0&a_{22}-\\lambda&a_{23}&\\cdots&a_{2N}\\\\\n0&0&a_{33}-\\lambda&\\cdots&a_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&a_{NN}-\\lambda\n\\end{vmatrix}=\\begin{vmatrix}\nu_{11}&u_{12}&u_{13}&\\cdots&u_{1N}\\\\\n0&u_{22}&u_{23}&\\cdots&u_{2N}\\\\\n0&0&u_{33}&\\cdots&u_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&u_{NN}\n\\end{vmatrix}=u_{11}u_{22}\\dots u_{NN}=0\n\nPada satu nilai eigen \\lambda tertentu ini maka persamaan nilai eigen memenuhi ungkapan berikut.(A-\\lambda I)x=LUx=O \\implies Ux=O\n\nDalam bentuk eksplisit, ungkapan tersebut dapat disajikan seperti berikut.\\begin{pmatrix}\nu_{11}&u_{12}&u_{13}&\\cdots&u_{1N}\\\\\n0&u_{22}&u_{23}&\\cdots&u_{2N}\\\\\n0&0&u_{33}&\\cdots&u_{3N}\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0&0&\\cdots&u_{NN}\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1\\\\ x_2\\\\ x_3\\\\\n\\vdots\\\\ x_N\n\\end{pmatrix}\n=\\begin{pmatrix}\n0\\\\ 0\\\\ 0\\\\\n\\vdots\\\\ 0\n\\end{pmatrix}\\implies \\begin{array}{lr}\n&u_{11}x_1+u_{12}x_2+u_{13}x_3+\\cdots+u_{1N}x_N=0\\\\\n&u_{22}x_2+u_{23}x_3+\\cdots+u_{2N}x_N=0\\\\\n&u_{33}x_3+\\cdots+u_{3N}x_N=0\\\\\n&\\vdots=\\vdots\\\\\n&u_{NN}x_N=0\n\\end{array}\n\nBerdasar ungkapan pada persamaan baris ke N di atas, nampak bahwa nilai x_N=0 dan akibatnya ketika dilakukan proses substitusi balik maka diperoleh fungsi eigen adalah nol yaitu x_i=0 untuk i=(N-1),\\cdots, 1. Penyelesaian seperti ini disebut penyelesaian trivial, yang tidak memberikan informasi apapun bagi sistem.\n\nUntuk memperoleh penyelesaian tak trivial, yaitu fungsi eigen yang tidak nol, maka baris ke N dapat dihilangkan sehingga tersisa sejumlah N-1 persamaan simultan dalam bentuk berikut\\begin{array}{rl}\nu_{11}x_1+u_{12}x_2+u_{13}x_3+\\cdots+u_{1(N-1)}x_{N-1}=&-u_{1N}x_N\\\\\nu_{22}x_2+u_{23}x_3+\\cdots+u_{2(N-1)}x_{N-1}=&-u_{2N}x_N\\\\\nu_{33}x_3+\\cdots+u_{3(N-1)}x_{N-1}=&-u_{3N}x_N\\\\\n\\vdots=&\\vdots\\\\\nu_{(N-1)(N-1)}x_{N-1}=&-u_{(N-1)N}x_N\\\\\n\\end{array}\n\nKarena baris ke N tidak diperhitungkan akibatnya nilai x_N menjadi tidak tentu atau bebas. Apabila untuk sementara nilai bebas bagi x_N ditentukan yaitu diambil x_N=1 maka seperangkat (N-1) persamaan simultan di atas akan dapat diperoleh berdasar proses substitusi balik sehingga diperoleh nilai untuk x_i dengan i=(N-1), \\cdots, 1.\n\nPada akhirnya fungsi eigen dapat diperoleh yaitu dengan mempersyaratkan bahwa fungsi eigen perlu ternormalisir oleh proses normalisasi seperti berikut.x_{\\text{norm}} = Cx;\\quad\\text{dengan}\\quad C=\\frac{1}{\\sqrt{x_1^2+x_2^2+\\cdots+x_N^2}};\\quad x_N = 1\n\nBerikut merupakan source-code bagi implementasi percarian fungsi eigen ternormalisir x_{norm} berdasar uraian di atas.\n\nfunction fung_eigen(A,dr,epsilon)\n    N = size(A, 1)\n    A_lambda = A .- epsilon * dr^2 * I(N)\n    L, U = lu_decomp(A_lambda)\n    x_norm = zeros(Float64,N)\n    U_new = U[1:(N-1),1:(N-1)] #Mengambil submatrik dari U dengan menghilangkan baris dan kolom ke N\n    b_new = -1.0*U[1:(N-1),N]   \n    x_new = back_subs(U_new,b_new)\n    sum = 1.0\n    for i in 1:(N-1)\n        sum += x_new[i]^2\n    end\n    C = 1.0/sqrt(sum)\n    x_norm = C * push!(x_new,1.0) #Menambahkan unsur x[N]=1.0 ke matrik kolom x yang sebelumnya berorde N-1\n\n    return x_norm\nend    \n\n\n\nfeigen = fung_eigen(A, dr, epsilon_new);\n\n\n\nplot(r, feigen;\n     xlabel=L\"y\",\n     ylabel=L\"\\psi(y)\",\n     title=\"Fungsi Gelombang dari Metode Eigen\",\n     grid=true, gridstyle=:solid)\n\n","type":"content","url":"/materi/pers-schrodinger-by-finite-diff-julia#pencarian-fungsi-eigen-untuk-sebarang-bentuk-matrik","position":23},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi"},"type":"lvl1","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia","position":0},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi"},"content":"","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia","position":1},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Latar Belakang"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#latar-belakang","position":2},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Latar Belakang"},"content":"Ketika suatu model yang mewakili suatu sistem fisis dapat diselesaikan, pada umunya penyelesaian suatu sistem fisis tersebut berupa suatu fungsional, yaitu bentuk kompak (closed form) yang melibatkan bentuk fungsi tertentu. Beberapa fungsi yang terlibat dalam penyelesaian boleh jadi berbentuk sederhana sehingga dapat langsung dimanfaatkan dalam perhitungan.\n\nNamun, fungsi yang terlibat dalam banyak penyelesaian kajian fisis ternyata tidak memiliki bentuk sederhana. Peran metode evaluasi fungsi  menjadi penting untuk kondisi seperti ini agar perilaku atau sifat penting  bagi fungsi dapat dipahami pada rentang peubah atau domain yang ditinjau dan akibatnya pemanfaatan penyelesaian bagi sistem yang melibatkan perhitungan fungsi akan dapat diperoleh.","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#latar-belakang","position":3},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Sistem Bandul"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#sistem-bandul","position":4},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Sistem Bandul"},"content":"Sebagai contoh maka dapat ditinjau suatu sistem bandul bermassa m yang digantungkan pada seutas tali dengan panjang l dan dipengaruhi oleh medan gravitasi bumi g. Salah satu bentuk penyelesaian gerak ayunan bandul pada simpangan \\theta pada waktu tertentu t akan dapat dinyatakan sebagai ungkapant=\\sqrt{\\frac{l}{g}}\\int_{\\pi/2}^{\\xi(\\theta)}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}; \\qquad k=\\sin\\frac{\\theta_0}{2}\n\nKaitan antara sudut simpangan \\theta terhadap peubah baru \\xi diberikan oleh kaitan\\sin\\frac{\\theta}{2}=k\\sin{\\xi}\n\nBerdasar ungkapan pers (1) maka periode bandul T dapat diungkapkan dalam bentukT=4\\,\\sqrt{\\frac{l}{g}}\\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}\n\nDengan ungkapan periode bandul T seperti diberikan pers (3) maka penyelesaian gerak bandul dalam pers (1) dapat diungkapkan dalam bentuk laint=\\sqrt{\\frac{l}{g}}\\int_{\\pi/2}^{\\xi(\\theta)}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}=\\sqrt{\\frac{l}{g}}\\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}-\\sqrt{\\frac{l}{g}}\\int_0^{\\xi(\\theta)}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}\n\nDengan ungkapan lain maka penyelesaian gerak bandul akan setara dengan bentukt=\\frac{T}{4}-\\sqrt{\\frac{l}{g}}\\int_0^{\\xi(\\theta)}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}\n\nDalam satuan universal atau besaran waktu yang tak bersatuan yaitu \\tau=\\tfrac{t}{T}, ungkapan pers (4a) dapat dinyatakan dalam bentuk\\tau=\\frac{1}{4}-\\frac{1}{4}\\frac{\\int_0^{\\xi(\\theta)}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}}{\\int_0^{\\pi/2}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}}","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#sistem-bandul","position":5},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Integral Eliptik"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#integral-eliptik","position":6},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Integral Eliptik"},"content":"Istilah integral eliptik dikaitkan dengan fungsi yang didefinisikan dalam bentuk integral layak tertentu, seperti diuraikan secara detail pada tautan \n\nIntegral Eliptik: Wikipedia atau \n\nIntegral Eliptik: Wolfram.\n\nIntegral Eliptik tak-lengkap jenis pertama (Incomplete elliptic integral of the first kind) F(\\theta_0,k) didefinisikan sebagaiF(\\theta_0,k)=\\int_0^{\\theta_0}\\,\\frac{d\\theta}{\\sqrt{1-k^2\\sin^2\\theta}}\n\nAdapun integral Eliptik lengkap jenis pertama (Complete elliptic integral of the first kind) K(k) didefinisikan sebagaiK(k)=\\int_0^{\\pi/2}\\,\\frac{d\\theta}{\\sqrt{1-k^2\\sin^2\\theta}}\n\nBerdasar definisi integral Eliptik tersebut maka penyelesaian gerak bandul dalam pers (4) dapat dinyatakan sebagai penyelesaian yang melibatkan fungsi dari integral Eliptik yaitu\\tau=\\frac{1}{4}\\left[1-\\frac{F\\left(\\xi,k\\right)}{K(k)}\\right]\n\nDengan pers (5) tersebut maka penyelesaian gerak bandul \\theta(t) beserta akan dapat ditentukan apabila evaluasi bagi fungsi integral Eliptik F\\left(\\xi(\\theta),k\\right) beserta K(k) berhasil dilakukan.","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#integral-eliptik","position":7},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Perhitungan Integral Eliptik"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#perhitungan-integral-eliptik","position":8},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Perhitungan Integral Eliptik"},"content":"Integral Eliptik merupakan salah satu fungsi khas (special functions) yang sering muncul dalam penyelesaian berbagai kajian fisika. Pada umumnya, sifat-sifat dari fungsi khas dinyatakan dalam berbagai ungkapan antara lain dalam bentuk integral, ekspansi deret pangkat, kaitan rekurensi, bentuk asimtotik serta dalam penyajian fungsi khas lainnya.\n\nUngkapan deret bagi integral Eliptik lengkap jenis pertama berbentukK(k)=\\frac{\\pi}{2}\\sum_{n=0}^\\infty\\left(\\frac{(2n)!}{2^{2n}(n!)^2}\\right)^2 k^{2n}K(k)=\\frac{\\pi}{2}\\left[1+\\left(\\frac{1}{2}\\right)^2 k^2+\\left(\\frac{1.3}{2.4}\\right)^2 k^4+\\cdots+\\left(\\frac{(2n-1)!!}{(2n)!!}\\right)^2 k^{2n}+\\cdots\\right]\n\nArti dari notasi faktorial ganda atau semifaktorial (n!!) pada pers (7b) dapat merujuk pada tautan \n\nDouble Factorial\n\nUngkapan deret bagi integral Eliptik tak-lengkap jenis pertama memiliki bentuk yang beragam sesuai rentang nilai argumen \\theta_0 dan k yang diberikan.\n\nDengan ungkapan pers (7a) maka periode bandul T akan dapat diperoleh apabila evaluasi ungkapan deret bagi ntegral Eliptik lengkap jenis pertama tersebut.\n\n","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#perhitungan-integral-eliptik","position":9},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Evaluasi Berdasar Kaitan Rekurensi"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-berdasar-kaitan-rekurensi","position":10},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Evaluasi Berdasar Kaitan Rekurensi"},"content":"Selain ungkapan penyajian deret, beberapa penyelesaian permasalahan fisika sering melibatkan fungsi khas (special function) yang disajikan dalam bentuk kaitan rekurensi. Sebagai contoh, bentuk fungsi gelombang yang merupakan penyelesaian bagi persamaan Schrodinger untuk sistem osilator harmonik dalam mekanika kuantum akan melibatkan fungsi khas yang disebut polinomial Hermite H_n(x) berorde n dalam bentuk\\psi_n(x)=\\frac{1}{\\sqrt{2^n\\,n!}}\\left(\\frac{m\\omega}{\\pi\\hbar}\\right)^{1/4}e^{-\\frac{m\\omega}{2\\hbar}x^2}H_n\\left(\\sqrt{\\frac{m\\omega}{\\hbar}}x\\right); \\quad n=0,1,2,\\cdots\n\nDalam ungkapan tersebut, m adalah massa benda, \\hbar=h/2 dengan h adalah tetapan Planck dan \\omega adalah frekuensi osilasi (lihat di tautan \n\nQuantum Harmonic Oscillator ).\n\nPolinomial Hermite H_n(x) berode n (\n\nHermite polynomials) dapat dinyatakan dalam ungkapan deret seperti berikutH_n(x)=\\begin{cases}\n    n!\\sum_{j=0}^{\\frac{n}{2}}\\frac{(-1)^{\\frac{n}{2}-j}}{(2j)!\\left(\\frac{n}{2}-j\\right)!}(2x)^{2j}       & \\quad \\text{jika } n\\, \\text{genap}\\\\\n    n!\\sum_{j=0}^{\\frac{n-1}{2}}\\frac{(-1)^{\\frac{n-1}{2}-j}}{(2j+1)!\\left(\\frac{n-1}{2}-j\\right)!}(2x)^{2j+1}  & \\quad \\text{jika } n\\, \\text{ganjil}\n  \\end{cases}\n\natau penyajian kaitan rekurensi seperti berikutH_{n+1}(x)=2xH_n(x)-2nH_{n-1}(x)\n\nSecara umum, ketika dua bentuk polinomial Hermite pada orde rendah diketahui yaitu H_0(x) dan H_1(x), maka perhitungan polinimial Hermite pada sebarang x dan sebarang orde n akan lebih mudah dilakukan berdasar kaitan rekurensi dibanding dengan penyajian deret. Berdasar\n\n","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-berdasar-kaitan-rekurensi","position":11},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Evaluasi Fungsi Integral Eliptik untuk Gerak Bandul"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-fungsi-integral-eliptik-untuk-gerak-bandul","position":12},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Evaluasi Fungsi Integral Eliptik untuk Gerak Bandul"},"content":"Ungkapan deret yang mewakili Integral  Eliptik lengkap jenis pertama, seperti diberikan oleh pars (7a) dan (7b), dapat dinyatakan dalam bentuk yang mirip pers (9) yaitu:K(k)=\\frac{\\pi}{2}\\sum_{n=0}^\\infty a_i=\\left(a_0+a_1 + a_2 +\\cdots+a_n +\\cdots\\right)\n\ndengan koefisien a_i diberikan oleh kaitan rekurensi berikuta_i=\\left[\\frac{k(2i-1)}{2i}\\right]^2\\,a_{i-1}; \\qquad a_0=1\n\nDibanding pers (7a) dan (7b), nampak bahwa bentuk pangkat orde tinggi beserta faktorial pada pers (18) menjadi tidak nampak secara eksplisit.\n\nSource code berikut adalah perhitungan nilai  K(k)  pada sebarang  k  berdasar implementasi ungkapan deret pers (18).\n\n    function my_ellipk(k)\n        ai = 1.0\n        sum = ai\n        for i in 1:19\n            ai *= (k * (2.0*i-1)/(2.0*i))^2\n            sum += ai\n        end\n        myseries = π * sum / 2.0\n        return myseries\n    end\n\n\n\nDengan membandingkan implementasi Source code tersebut dengan package SpecialFunctions dalam Julia untuk fungsi Integral  Eliptik lengkap jenis pertama yaitu ellipk nampak bahwa hasil keduanya telah sesuai.\n\nusing SpecialFunctions\n\nk = 0.6\nm = k*k\nellip = ellipk(m);\neksak = my_ellipk(k);\n\n\n\nellip, eksak\n\n\n\n","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-fungsi-integral-eliptik-untuk-gerak-bandul","position":13},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl3":"Evaluasi Integral Eliptik Lengkap Jenis  Pertama dengan Metode Rekurensi","lvl2":"Evaluasi Fungsi Integral Eliptik untuk Gerak Bandul"},"type":"lvl3","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-integral-eliptik-lengkap-jenis-pertama-dengan-metode-rekurensi","position":14},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl3":"Evaluasi Integral Eliptik Lengkap Jenis  Pertama dengan Metode Rekurensi","lvl2":"Evaluasi Fungsi Integral Eliptik untuk Gerak Bandul"},"content":"Selain dapat disajikan dengan ungkapan deret, Integral Eliptik lengkap jenis pertama dapat dilakukan lebih efektif dengan memanfaatkan ungkapan rekursif. Bentuk integral eliptik lengkap jenis pertama K(k) dapat dinyatakan dalam fungsi \n\nArithmetic–Geometric Mean (AGM), yang dinotasikan oleh M(x,y), oleh kaitanK(k)=\\frac{\\pi}{2M(1,\\sqrt{1-k^2})}\n\nEvaluasi fungsi AGM M(x,y) didasarkan pada prosedur berikut:\n\nTinjau jajaran nilai-nilai a_i dan g_i untuk i=0,1,2,\\cdots\n\nMulai jajaran dengan x dan y yaitu a_0=x dan g_0=y\n\nLanjutkan jajaran berikutnya dengan kaitan rekurensi:\n\na_{i+1}=\\frac{1}{2}\\left(a_i+g_i\\right)\n\ng_{i+1}=\\sqrt{a_i g_i}\n\nDua jajaran  a_i dan g_i akan konvergen pada satu nilai fungsi AGM yaitu  M(x,y)\n\nDengan prosedur tersebut maka evaluasi fungsi M(1,\\sqrt{1-k^2}) untuk memperoleh nilai  Integral Eliptik lengkap jenis pertama seperti diberikan pers (20) adalah seperti berikut:\n\nfunction my_ellipk_rekurensi(k)\n    a0 = 1.0\n    g0 = sqrt(1.0 - k^2)\n    for i in 1:10\n        ai = (a0 + g0) / 2.0\n        gi = sqrt(a0 * g0)\n        a0 = ai\n        g0 = gi\n    end\n    myrekur = π / (2.0 * a0)\n    return myrekur\nend\n\n\n\nmyrekur=my_ellipk_rekurensi(k)\n\n\n\nNampak dari hasil di atas bahwa nilai K(k) yang diperoleh berdasar metode deret serta metode rekurensi telah sesuai, namun metode rekurensi nampak lebih cepat untuk konvergen.\n\n","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-integral-eliptik-lengkap-jenis-pertama-dengan-metode-rekurensi","position":15},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Evaluasi Integral Eliptik Tak Lengkap Jenis Pertama"},"type":"lvl2","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-integral-eliptik-tak-lengkap-jenis-pertama","position":16},{"hierarchy":{"lvl1":"Gerak Bandul dengan Evaluasi Fungsi","lvl2":"Evaluasi Integral Eliptik Tak Lengkap Jenis Pertama"},"content":"Dalam masalah perhitungan periode bandul, evaluasi Integral Eliptik tak-lengkap jenis pertama (Incomplete elliptic integral of the first kind) dilakukan dengan integrasi numerik yaitu metode Simpson. Untuk masalah gerak bandul, yaitu menentukan simpangan bandul sebagai fungsi waktu, evaluasi Integral Eliptik tak-lengkap jenis pertama perlu dilakukan beberapa kali sehingga penggunaan kuadratur numerik akan nampak lebih efisien. Ungkapan Integral Eliptik tak-lengkap jenis pertama F(\\xi,k) disajikan oleh pers (5a) yaitu:F(\\xi,k)=\\int_0^{\\xi}\\,\\frac{d\\xi}{\\sqrt{1-k^2\\sin^2\\xi}}\n\nMemanfaatkan uraian yang diberikan pada materi kuliah terdahulu terkait implementasi metode kuadratur numerik pada perhitungan periode bandul maka source-code untuk perhitungan Integral Eliptik tak-lengkap jenis pertama F(\\xi,k) disajikan oleh pers (21) adalah seperti berikut:\n\nusing FastGaussQuadrature\n\nfunction fung(x, k)\n  return 1.0 / sqrt(1.0 - (k * sin(x))^2)\nend\n\nfunction my_ellip_in(xi, k)\n  n = 15\n  # Legendre-Gauss nodes and weights\n  x, c = gausslegendre(n)\n  a = 0.0\n  b = xi\n  sum = 0.0\n  for i in 1:n\n    y = (b - a) * x[i] / 2.0 + (b + a) / 2.0\n    sum += c[i] * fung(y, k)\n  end\n  my_quad = (b - a) * sum / 2.0\n  return my_quad\nend\n\n\n\nusing EllipticFunctions\n\nconst pi = π\ntheta0 = pi/4.0\nk = sin(theta0/2.0)\ntheta = pi/6.0\np = sin(theta/2.0)\nxi = asin(p/k)\nm = k*k\n\ninc_ellip = ellipticF(xi, m);\nhasil = my_ellip_in(xi, k);\n\n\n\ninc_ellip, hasil\n\n\n\nNampak dari hasil di atas bahwa nilai F(\\xi,k) yang diperoleh berdasar metode kuadratur numerik dibanding fungsi ellipticF dari package EllipticFunctions dalam Julia telah sesuai.\n\nDengan evaluasi fungsi-fungsi tersebut maka penyelesaian gerak baandul melalui perhitungaan waktu \\tau sebagai fungsi simpangan theta, dan inversnya yaitu \\theta sebagai fungsi waktu \\tau, akan dapat diperoleh.\n\nn = 30\ntheta = range(pi/n, pi/4, length=n)\ntau = zeros(n)\neksak = zeros(n)\ntheta0 = pi/3.0\nk = sin(theta0/2.0)\nfor i in 1:n\n    p = sin(theta[i]/2.0)\n    xi = asin(p/k)\n    inc_ellip = my_ellip_in(xi, k)\n    ellip = my_ellipk_rekurensi(k)\n    tau[i] = 0.25 * (1.0 - inc_ellip / ellip)\n    eksak[i] = theta0 * cos(2 * pi * tau[i])\nend\n\nusing Plots\nplot(tau, theta, label=\"theta\")\nplot!(tau, eksak, label=\"eksak\")\n\n\n\nDari plot di atas nampak bahwa hasil penyelesaian gerak berdasar evaluasi fungsi telah sesuai dengan hasil eksak yang diperoleh saat sudut simpangan awal kecil. Dengan demikian hasil penyelesaian gerak berdasar evaluasi fungsi dapat digunakan untuk sebarang simpangan.","type":"content","url":"/materi/gerak-bandul-by-evaluasi-fungsi-julia#evaluasi-integral-eliptik-tak-lengkap-jenis-pertama","position":17},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik"},"type":"lvl1","url":"/materi/penyelesaian-pers-diffusi-julia","position":0},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik"},"content":"","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia","position":1},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Implementasi untuk Persmaan Difusi Panas"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#implementasi-untuk-persmaan-difusi-panas","position":2},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Implementasi untuk Persmaan Difusi Panas"},"content":"Contoh permasalahan yang memerlukan ongkos komputasi tinggi diantaranya adalah penyelesaian persamaan diferensial parsial, yaitu suatu persamaan diferensial yang melibatkan lebih dari satu peubah bebas. Adanya lebih dari satu peubah bebas menyebabkan munculnya pertimbangan langkah diskretisasi karena diskretisasi pada satu peubah bebas akan berpotensi menimbulkan dampak pada diskretisasi peubah bebas lainnya. Pertimbangan yang nampak perlu dipertimbangkan adalah munculnya dimensi matrik yang luar biasa besar untuk mendapatkan hasil yang stabil dan ketelitian yang memadai.\n\nPada umumnya ada 3 jenis persamaan diferensial parsial yaitu\n\nPersamaan diferensial eliptik dengan contoh yaitu\n\na. Persamaan Poisson dalam bentuk\\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial y^2}=S(x,y)\n\nb. Persamaan Schrodinger tak gayut waktu dalam bentuk-\\frac{\\hbar^2}{2m}\\left[\\frac{\\partial^2 \\psi}{\\partial x^2}+\\frac{\\partial^2 \\psi}{\\partial y^2}\\right]+\\hat{V}(x,y)\\psi=E\\psi\n\nPersamaan diferensial parabolik dengan contoh yaitu\n\na. Persamaan difusi dalam bentukk\\frac{\\partial^2 u}{\\partial x^2}-\\frac{\\partial u}{\\partial t}=f(x,t)\n\nb. Persamaan Scrodinger gayut waktu dalam bentuki\\hbar\\frac{\\partial \\psi}{\\partial t}= -\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\psi}{\\partial x^2}+\\hat{V}(x)\\psi = \\hat{H}\\psi\n\nPersamaan diferensial hiperbolik dengan contoh yaitu\n\nPersamaan gelombang dalam bentukc^2\\frac{\\partial^2 u}{\\partial x^2}-\\frac{\\partial u}{\\partial t^2}=f(x,t)","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#implementasi-untuk-persmaan-difusi-panas","position":3},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Penyelesaian Persamaan Difusi dengan Metode Beda Hingga"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#penyelesaian-persamaan-difusi-dengan-metode-beda-hingga","position":4},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Penyelesaian Persamaan Difusi dengan Metode Beda Hingga"},"content":"Dari bentuk persamaan diferensial parabolik di atas akan nampak bahwa adanya bentuk turunan satu kali terhadap peubah bebas waktu (t) maka penyelesaian akan melibatkan masalah syarat awal, mirip seperti penyelesaian pada gerak bandul. Dilain pihak,  adanya bentuk turunan dua kali terhadap peubah bebas posisi (x) maka penyelesaian akan melibatkan masalah syarat batas, mirip seperti penyelesaian pada persamaan Poisson. Untuk masalah syarat awal maka hal yang perlu mendapat perhatian adalah pada persyaratan kestabilan, sedangkan masalah syarat batas maka hal yang perlu mendapat perhatian adalah pada persyaratan ketelitian. Kedua hal tersebut akan memunculkan suatu ungkapan umum dalam penyelesaian persamaan diferensial parabolik bahwa kestabilan dan ketelitian akan dapat dicapai apabila memenuhi ungkapan berikut.\\frac{k\\Delta t}{(\\Delta x)^2}\\le 1\n\nBentuk persamaan difusi panas T(x,t) dalam 1 dimensi adalah:\\frac{\\partial T}{\\partial t}=D\\frac{\\partial^2 T}{\\partial x^2}+S(x,t)\n\nDalam ungkapan di atas, D adalah koefisien difusi panas dan S(x,t) adalah sumber panas dengan a\\le x\\le b. Syarat awal dan syarat\nbatas yang diberikan dianggap berjenis Derichlet yaitu\\begin{align*}\nT(a,t) &= T_a\\\\\nT(b,t) &= T_b\\\\\nT(x,0) &= T_0(x)\n\\end{align*}\n\nYang menjadi tujuan dari masalah penyelesaian difusi panas adalah untuk memperoleh distribusi temperatur  pada sebarang ruang dan waktu yaitu T(x,t). Dalam masalah ini maka  sumber panas S(x,t) dianggap diketahui, termasuk nilai temperatur pada waktu awal T(x,0) serta nilai temperatur pada batas daerah di x=a serta x=b, yaitu  T(a,t), T(b,t), semuanya telah diketahui.\n\nPenyelesaian difusi panas merupakan gabungan antara penyelesian masalah syarat awal dan syarat batas karena bentuk persamaan diferensial adalah bertipe persamaan parabolik. Pada umumnya, hal yang perlu menjadi perhatian dalam tipe penyelesaian persamaan diferensial parabolik adalah potensi terjadinya ketakstabilan pada langkah numerik.\n\nUntuk memudahkan penulisan dalam prosedur komputasi, penyelesaian difusi panas akan menggunakan notasi diskret x_n untuk posisi pada titik ke n=0, \\cdots, N dan t_j untuk waktu pada saat ke j=0, \\cdots, J. Dengan demikian, sebarang posisi dapat didekati dengan posisi diskret x_n yang memiliki kaitan:x_n=x_0+n\\Delta x\n\ndengan \\Delta x=\\frac{x_N-x_0}{N} adalah ukuran langkah (\\textit{step size}) sedangkan x_0=a dan x_N=b adalah posisi di kedua ujung batas daerah.\n\nDengan cara yang sama, sebarang waktu dapat didekati dengan waktu diskret t_j yang memiliki kaitan:t_j=t_0+j\\Delta t\n\ndengan \\Delta t=\\frac{t_J-t_0}{J} adalah selang waktu (\\textit{time step}) sedangkan t_0 dan t_J adalah waktu awal dan akhir.\n\nNotasi untuk nilai diskret temparatur dan sumber panas pada posisi x_n dan waktu t_j, yaitu T(x_n, t_j) dan S(x_n, t_j), biasa ditulisT_n^j\\equiv T(x_n, t_j);\\qquad S_n^j\\equiv S(x_n, t_j)","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#penyelesaian-persamaan-difusi-dengan-metode-beda-hingga","position":5},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Ungkapan beda hingga (finite difference)","lvl2":"Penyelesaian Persamaan Difusi dengan Metode Beda Hingga"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#ungkapan-beda-hingga-finite-difference","position":6},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Ungkapan beda hingga (finite difference)","lvl2":"Penyelesaian Persamaan Difusi dengan Metode Beda Hingga"},"content":"Bentuk diskret operasi diferensial bagi sebarang fungsi f(y) terhadap peubah bebas y dapat dinyatakan dalam ungkapan beda hingga berikut\n\nBeda hingga maju (forward difference) untuk operasi diferensial satu kali\\left.\\frac{df(y)}{dy}\\right]_{y=y_n}\\approx\\frac{f_{n+1}-f_n}{\\Delta y}\n\nBeda hingga mundur (backward difference) untuk operasi diferensial satu kali\\left.\\frac{df(y)}{dy}\\right]_{y=y_n}\\approx\\frac{f_{n}-f_{n-1}}{\\Delta y}\n\nBeda hingga terpusat (central difference) untuk operasi diferensial satu kali\\left.\\frac{df(y)}{dy}\\right]_{y=y_n}\\approx\\frac{f_{n+1}-f_{n-1}}{2\\Delta y}\n\nBeda hingga terpusat (central difference) untuk operasi diferensial dua kali\\left.\\frac{d^2f(y)}{dy^2}\\right]_{y=y_n}\\approx\\frac{f_{n+1}-2f_n+f_{n-1}}{\\Delta y^2}","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#ungkapan-beda-hingga-finite-difference","position":7},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#penyelesaian-dengan-metode-beda-hingga-finite-difference","position":8},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"content":"","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#penyelesaian-dengan-metode-beda-hingga-finite-difference","position":9},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Skema eksplisit","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#skema-eksplisit","position":10},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Skema eksplisit","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"content":"Persamaan difusi panas di atas dapat ditulis dalam bentuk diskret, yang disebut persamaan beda hingga, dengan memanfaatkan ungkapan beda hingga maju (forward difference) untuk operasi diferensial satu kali terhadap waktu dan ungkapan beda hingga terpusat (central difference) untuk operasi diferensial dua kali terhadap posisi, sehingga berubah menjadi\\left(\\frac{T_n^{j+1}-T_n^j}{\\Delta t}\\right)=D\\left(\\frac{T_{n+1}^j-2T_n^j+T_{n-1}^j}{{\\Delta x}^2}\\right)+S_n^j\n\ndengan n=1, \\cdots, N-1, j=0, \\cdots, J, dan T_n^0, T_0^j, T_N^j semuanya memiliki nilai yang telah diketahui. Penyelesaian persamaan beda hingga dengan skema eksplisit dapat dilakukan dengan mengubah ungkapan tersebut ke dalam bentukT_n^{j+1}=\\lambda T_{n-1}^j+\\left(1-2\\lambda\\right)T_n^j+\\lambda T_{n+1}^j+\\Delta t S_n^j\n\nDalam ungkapan di atas digunakan parameter \\lambda=D\\frac{\\Delta t}{{\\Delta x}^2}.\n\nUngkapan di atas disebut skema eksplisit karena dengan mengetahui nilai-nilai T_n^0, T_0^j, T_N^j maka nilai-nilai T_n^j akan dapat dihitung secara langsung dari ungkapan tersebut. Skema eksplisit tersebut dapat dinyatakan dalam operasi matrik seperti berikut.\\begin{pmatrix} T_1^{j+1}\\\\ T_2^{j+1}\\\\ \\vdots\\\\ T_{N-1}^{j+1}\\end{pmatrix}=\\begin{pmatrix}\n  (1-2\\lambda) & \\lambda & 0 & \\cdots & 0 \\\\\n  \\lambda & (1-2\\lambda) & \\lambda &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & \\lambda & (1-2\\lambda)\n \\end{pmatrix}\\begin{pmatrix} T_1^j\\\\ T_2^j\\\\ \\vdots\\\\ T_{N-1}^j \\end{pmatrix}\n +\\Delta t\\begin{pmatrix} S_1^j\\\\ S_2^j\\\\ \\vdots\\\\ S_{N-1}^j\\end{pmatrix}+\\lambda\\begin{pmatrix} T_0^j\\\\ 0\\\\ \\vdots\\\\ T_N^j\\end{pmatrix}\n\nMeskipun skema eksplisit nampak sederhana dari aspek komputasi, namun umum diketahui bahwa skema tersebut memiliki perilaku penyelesaian yang tidak baik yaitu tidak stabil. Dapat ditunjukkan bahwa untuk pengambilan selang waktu \\Delta t yang tidak kecil dibanding (\\Delta x)^2 maka akan memunculkan penyelesaian yang tidak benar, bahkan cenderung sangat berbeda jauh dengan nilai yang seharusnya.","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#skema-eksplisit","position":11},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Skema implisit","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#skema-implisit","position":12},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Skema implisit","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"content":"Untuk mengatasi kendala ketakstabilan tersebut maka dapat ditempuh skema implisit. Ada banyak cara untuk memperoleh ungkapan bagi skema implisit. Salah satu cara adalah dengan meninjau ungkapan beda hingga mulai pada waktu t_1 sehingga dapat dimanfaatkan beda hingga mundur (backward difference) pada operasi diferensial satu kali terhadap waktu. Dengan demikian ungkapan persamaan beda hingga akan menjadi\\left(\\frac{T_n^{j+1}-T_n^j}{\\Delta t}\\right)=D\\left(\\frac{T_{n+1}^{j+1}-2T_n^{j+1}+T_{n-1}^{j+1}}{{\\Delta x}^2}\\right)+S_n^{j+1}\n\nDalam ungkapan lain maka dapat disajikan dalam bentuk-\\lambda T_{n-1}^{j+1}+\\left(1+2\\lambda\\right)T_n^{j+1}-\\lambda T_{n+1}^{j+1}=T_n^j+\\Delta t S_n^{j+1}\n\nDalam ungkapan di atas dapat dilihat bahwa perhitungan nilai T_n^{j+1} belum dapat diperoleh karena pada saat yang sama, nilai-nilai T_{n-1}^{j+1} dan \\psi_{n+1}^{j+1} belum diketahui. Dengan kenyataan ini maka disebut skema implisit karena nilai T_n^{j+1} tidak dapat dinyatakan secara eksplisit dari nilai T lainnya yang diketahui.\n\nUntuk memperoleh nilai-nilai T_n^{j+1} maka ungkapan persamaan linear di atas perlu diselesaikan secara simultan dengan persamaan linear lainnya berupa ungkapan persamaan matriks. Untuk mengetahui bentuk-bentuk matrik yang terlibat maka ungkapan skema implisit di atas dapaat dinyatakan dalam bentuk\\begin{pmatrix}\n  (1+2\\lambda) & -\\lambda & 0 & \\cdots & 0 \\\\\n  -\\lambda & (1+2\\lambda) & -\\lambda &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & -\\lambda & (1+2\\lambda)\n \\end{pmatrix}\\begin{pmatrix} T_1^{j+1}\\\\ T_2^{j+1}\\\\ \\vdots\\\\ T_{N-1}^{j+1} \\end{pmatrix}=\n \\begin{pmatrix} T_1^j+\\lambda T_0^{j+1}\\\\ T_2^j\\\\ \\vdots\\\\ T_{N-1}^j+\\lambda T_N^{j+1}\\end{pmatrix}\n +\\Delta t\\begin{pmatrix} S_1^{j+1}\\\\ S_2^{j+1}\\\\ \\vdots\\\\ S_{N-1}^{j+1}\\end{pmatrix}\n\nNampak bahwa ungkapan tersebut merupakan bentuk operasi perkalian matrik dalam bentuk Ay=b, dengan matrik tridiagonal A dan matrik kolom b memiliki unsur-unsur matrik yang diketahui. Matrik y merupakan matrik kolom yang memiliki unsur matrik berupa nilai-nilai T_n^j pada lokasi diskrit x_n dan waktu t_j.\n\nDengan demikian, masalah untuk menyelesaikan persamaan difusi panas menggunakan skema implisit adalah masalah untuk memperoleh matrik kolom y berdasarkan operasi matrik Ay=b ketika matrik A dan b telah diketahui. Beberapa operasi matrik baku dapat dipilih untuk penyelesaian ini.\n\nKeunggulan dari skema implisit ketika dibandingkan dengan skema eksplisit adalah tidak munculnya ketakstabilan dalam proses komputasi, meskipun dilakukan pada selang waktu \\Delta t yang tidak kecil dibanding (\\Delta x)^2.\n\nNamun kerugian dari skema implisit dibandingkan dengan skema eksplisit adalah mahal pada ongkos proses komputasi (computationally costly) mengingat operasi matrik perlu dilakukan untuk setiap selang waktu yang diambil.\n\nSecara ringkas dapat ditunjukkan melalui skema eksplisit dan implisit bahwa penyelesaian persamaan difusi panas dapat ditempuh dengan menggunakan proses komputasi yang berdasar pada metode beda hingga.\n\nSelanjutnya akan ditunjukkan bahwa metode beda hingga memiliki kendala alamiah yang sulit dihilangkan ketika digunakan untuk menyelesaikan permasalahan persamaan diferensial parabolik. Oleh karena itu akan ditinjau metode lain yang dapat mengatasi kendala tersebut.","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#skema-implisit","position":13},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Skema implisit Crank-Nicholson","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#skema-implisit-crank-nicholson","position":14},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Skema implisit Crank-Nicholson","lvl2":"Penyelesaian dengan Metode Beda Hingga (Finite Difference)"},"content":"Skema implisit seperti diuraikan di atas sudah cukup untuk menjamin bahwa kestabilan proses komputasi akan tercapai. Namun tujuan komputasi bukanlah hanya kestabilan namun juga ketelitian hasil komputasi. Salah satu skema implisit yang memfasilitasi hal tersebut adalah apa yang disebut metode Crank-Nicholson.\n\nMetode Crank-Nicholson didasarkan pada pengambilan pendekatan tinggi yaitu orde 2 baik pada diskretisasi waktu t maupun diskretisasi ruang x. Dalam orde 2 tersebut maka diskretisasi waktu t dievaluasi pada waktu t=t_{j+1/2} sehingga dapat digunakan pendekatan beda hingga terpusat dalam bentuk\\left.\\frac{\\partial T}{\\partial t}\\right]_{t=t_{j+1/2}}\\approx\\frac{T_n^{j+1}-T_n^j}{\\Delta t}\n\nEvaluasi pada t=t_{j+1/2} tidak menimbulkan kesulitan pada diskretisasi waktu namun akan meumunculkan kendala ketika digunakan untuk melakukan pendekatan beda hingga terpusat pada diskretisasi ruang karena nilai T pada posisi sebarang saat t=t_{j+1/2} tidak tersedia. Sebagai alternatif maka digunakan pendekatan nilai tengah yaitu nilai rerata T pada saat T=t_j dan saat t=t_{j+1} dalam bentuk\\begin{align*}\n\\left.\\frac{\\partial^2 T}{\\partial x^2}\\right]_{x=x_n}^{t=t_{j+1/2}}&\\approx \\frac{1}{2}\\left(\\left.\\frac{\\partial^2 T}{\\partial x^2}\\right]_{x=x_n}^{t=t_j}+\\left.\\frac{\\partial^2 T}{\\partial x^2}\\right]_{x=x_n}^{t=t_{j+1}}\\right)\\\\\n&\\approx\\frac{T_{n+1}^j-2T_n^j+T_{n-1}^j}{2\\Delta x^2}+\\frac{T_{n+1}^{j+1}-2T_n^{j+1}+T_{n-1}^{j+1}}{2\\Delta x^2}\n\\end{align*}\n\nUngkapan beda hingga bagi persamaan difusi panas berdasar skema tersebut menjadi\\frac{T_n^{j+1}-T_n^j}{\\Delta t}=D\\left(\\frac{T_{n+1}^j-2T_n^j+T_{n-1}^j}{2\\Delta x^2}+\\frac{T_{n+1}^{j+1}-2T_n^{j+1}+T_{n-1}^{j+1}}{2\\Delta x^2}\\right)+S_n^{j+1/2}\n\nUngkapan tersebut biasa disebut skema implisit Crank-Nicholson yang disajikan dalam bentuk-\\lambda T_{n-1}^{j+1}+2\\left(1+\\lambda\\right)T_n^{j+1}-\\lambda T_{n+1}^{j+1}=\\lambda T_{n-1}^j+2\\left(1-\\lambda\\right)T_n^j+\\lambda T_{n+1}^j+2\\Delta t S_n^{j+1/2}\n\nDalam operasi matrik, skema implisit Crank-Nicholson dapat dinyatakan dalam bentuk\\begin{align*}\n&\\begin{pmatrix}\n  2(1+\\lambda) & -\\lambda & 0 & \\cdots & 0 \\\\\n  -\\lambda & 2(1+\\lambda) & -\\lambda &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & -\\lambda & 2(1+\\lambda)\n \\end{pmatrix}\\begin{pmatrix} T_1^{j+1}\\\\ T_2^{j+1}\\\\ \\vdots\\\\ T_{N-1}^{j+1} \\end{pmatrix}=\n \\lambda\\begin{pmatrix} T_0^j+T_0^{j+1}\\\\ 0\\\\ \\vdots\\\\ T_N^j+T_N^{j+1}\\end{pmatrix}\n +\\Delta t\\begin{pmatrix} S_1^{j+1/2}\\\\ S_2^{j+1/2}\\\\ \\vdots\\\\ S_{N-1}^{j+1/2}\\end{pmatrix}\\\\\n &+\\begin{pmatrix}\n  2(1-\\lambda) & \\lambda & 0 & \\cdots & 0 \\\\\n  \\lambda & 2(1-\\lambda) & \\lambda &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & \\lambda & 2(1-\\lambda)\n \\end{pmatrix}\\begin{pmatrix} T_1^j\\\\ T_2^j\\\\ \\vdots\\\\ T_{N-1}^j \\end{pmatrix}\n\\end{align*}\n\nSecara umum, metode Crank-Nicholson memiliki kelebihan dalam konteks kestabilan dan ketelitian hasil komputasi dibanding dua metode yang dijelaskan sebelumnya, namun dengan kelemahan terkait ongkos komputasi yang relatif lebih mahal dibanding dua metode lain yang disinggung tersebut.\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#skema-implisit-crank-nicholson","position":15},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Source code Skema Eksplisit"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#source-code-skema-eksplisit","position":16},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Source code Skema Eksplisit"},"content":"\n\nusing LinearAlgebra\nusing Plots\nusing LaTeXStrings\n\nNx = 100\nNt = 1000\nD = 1.0\n\nx = range(-5, 5, length = Nx)\nt = range(0, 10, length = Nt)\n\ndx = x[2] - x[1]\ndt = t[2] - t[1]\n\nlambda = D * dt / dx^2\n\ntemper = zeros(Float64, Nx, Nt)\ntemper[:, 1] = exp.(-x.^2)\ntemper[1, :] .= 0.0\ntemper[end, :] .= 0.0;    \n\n\n\n\n# Plot the initial condition\nplot(x, temper[:, 1],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\n\nfunction matrix_eksplisit(lambda, Nx)\n    a = (1.0 - 2.0 * lambda) * ones(Nx-2)\n    b = lambda * ones(Nx-3)\n    A = zeros(Nx-2, Nx-2)\n    A = diagm(0 => a, -1 => b, 1 => b)\n    return A\nend\n\n\n\nA = matrix_eksplisit(lambda, Nx);\n\n\n\nfunction skema_eksplisit(temper, A, Nt)\n    for j in 1:(Nt-1)\n        temper[2:end-1, j+1] = A * temper[2:end-1, j]\n    end\n    return temper\nend \n\n\n\ntemper = skema_eksplisit(temper, A, Nt);\n\n\n\nplot(x, [temper[:, 25],temper[:, 20], temper[:, 1]],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#source-code-skema-eksplisit","position":17},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Source code Skema Implisit"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#source-code-skema-implisit","position":18},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Source code Skema Implisit"},"content":"\n\nNx = 100\nNt = 1000\nD = 1.5\n\nx = range(-5, 5, length = Nx)\nt = range(0, 10, length = Nt)\n\ndx = x[2] - x[1]\ndt = t[2] - t[1]\n\nlambda = D * dt / dx^2\n\ntemper = zeros(Float64, Nx, Nt)\ntemper[:, 1] = exp.(-x.^2)\ntemper[1, :] .= 0.0\ntemper[end, :] .= 0.0;    \n\n\n\nplot(x, temper[:, 1],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\nfunction matrix_implisit(lambda, Nx)\n    a = (1.0 + 2.0 * lambda) * ones(Nx-2)\n    b = -lambda * ones(Nx-3)\n    A = zeros(Nx-2, Nx-2)\n    A = diagm(0 => a, -1 => b, 1 => b)\n    return A\nend\n\n\n\nA = matrix_implisit(lambda, Nx);\nfor i in 1:(Nt-1)\n    temper[2:Nx-1, i+1] = A \\ temper[2:Nx-1, i];\nend\n\n\n\nplot(x, [temper[:, 100],temper[:, 10], temper[:, 1]],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\nfunction skema_implisit(A, temper, lambda, Nt, Nx)\n    d = diag(A)\n    e = diag(A, -1)\n    b = diag(A, 1)\n    m = zeros(Nx-3)\n    y = zeros(Nx-2)\n    for i in 2:(Nx-2)             \n        m[i-1] = e[i-1] / d[i-1]\n        d[i] -= m[i-1] * b[i-1]\n    end\n\n    for j in 1:(Nt-1)\n        y = temper[2:end-1, j]\n        for i in 3:(Nx-1)             \n            y[i-1] -= m[i-2] * y[i-2]\n        end\n        temper[Nx-1,j+1] = temper[Nx-1,j] / d[Nx-2]\n        for i in (Nx-2):-1:2\n            temper[i,j+1] = (y[i-1] - b[i-1] * temper[i+1,j+1]) / d[i-1]\n        end\n    end\n\n    return temper\nend\n\n\n\ntemper = skema_implisit(A, temper, lambda, Nt, Nx);\n\n\n\nplot(x, [temper[:, 100],temper[:, 10], temper[:, 1]],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\ncontour(x, t, temper',\n        xlabel=L\"$x$\",\n        ylabel=L\"$t$\",\n        title=\"Contour Plot\",\n        fill=true)\n\n\n\nsurface(x, t, temper',\n        xlabel=L\"$x$\",\n        ylabel=L\"$t$\",\n        zlabel=L\"$T(x,t)$\",\n        title=\"Surface Plot\")\n\n\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#source-code-skema-implisit","position":19},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Source code Skema Crank Nicholson"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#source-code-skema-crank-nicholson","position":20},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Source code Skema Crank Nicholson"},"content":"\n\nNx = 100\nNt = 100\nD = 1.0\n\nx = range(-5, 5, length = Nx)\nt = range(0, 10, length = Nt)\n\ndx = x[2] - x[1]\ndt = t[2] - t[1]\n\nlambda = D * dt / dx^2\n\ntemper = zeros(Float64, Nx, Nt)\ntemper[:, 1] = exp.(-x.^2)\ntemper[1, :] .= 0.0\ntemper[end, :] .= 0.0;    \n\n\n\nfunction matrix_kanan(lambda, Nx)\n    a = 2.0 * (1.0 - lambda) * ones(Nx-2)\n    b = lambda * ones(Nx-3)\n    A = zeros(Nx-2, Nx-2)\n    A = diagm(0 => a, -1 => b, 1 => b)\n    return A\nend\n\n\n\nfunction matrix_kiri(lambda, Nx)\n    a = 2.0 * (1.0 + lambda) * ones(Nx-2)\n    b = -lambda * ones(Nx-3)\n    A = zeros(Nx-2, Nx-2)\n    A = diagm(0 => a, -1 => b, 1 => b)\n    return A\nend\n\n\n\nfunction skema_CN(A_kanan, A_kiri, temper, lambda, Nt, Nx)\n    d = diag(A_kiri)\n    e = diag(A_kiri, -1)\n    b = diag(A_kiri, 1)\n    m = zeros(Nx-3)\n    y = zeros(Nx-2)\n    for i in 2:(Nx-2)             \n        m[i-1] = e[i-1] / d[i-1]\n        d[i] -= m[i-1] * b[i-1]\n    end\n\n    for j in 1:(Nt-1)\n        y = A_kanan * temper[2:end-1, j]\n        for i in 3:(Nx-1)             \n            y[i-1] -= m[i-2] * y[i-2]\n        end\n        temper[Nx-1,j+1] = y[Nx-2] / d[Nx-2]\n        for i in (Nx-2):-1:2\n            temper[i,j+1] = (y[i-1] - b[i-1] * temper[i+1,j+1]) / d[i-1]\n        end\n    end\n\n    return temper\nend\n\n\n\nA_kiri = matrix_kiri(lambda, Nx);\nA_kanan = matrix_kanan(lambda, Nx);\n\n\n\ntemper = skema_CN(A_kanan, A_kiri, temper, lambda, Nt, Nx);\n\n\n\nplot(x, [temper[:, 100],temper[:, 10], temper[:, 1]],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#source-code-skema-crank-nicholson","position":21},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Komputasi berdasar Ekponensial Matrik"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#komputasi-berdasar-ekponensial-matrik","position":22},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Komputasi berdasar Ekponensial Matrik"},"content":"Suatu prosedur penyelesaiaan persamaan diferensial parsial parabolik yang agak berbeda dengan yang diuraikan di atas dapat ditempuh dengan cara berikut. Ditinjau penyelesaian persamaan difusi panas ketika langkah diskretisasi hanya dilakukan dalam peubah posisi  x sedangkan peubah waktu t tetap dalam ungkapan kontinu. Apabila nilai temperatur pada dua titik batas diberikan kondisi berikut yaitu T(a,t)=0 dan T(b,t)=0 dan tidak ada sumber panas yaitu S(x,t)=0, maka persamaan difusi panas dapat ditulis dalam bentuk berikut\\begin{align*}\n\\frac{\\partial}{\\partial t}\\underbrace{\\begin{pmatrix}  T_1^t\\\\  T_2^t\\\\ \\vdots\\\\  T_{N-1}^t\\end{pmatrix}}_{T(x,t)}&=\\underbrace{\\begin{pmatrix}\n  -2\\gamma & \\gamma & 0 & \\cdots & 0 \\\\\n  \\gamma & -2\\gamma & \\gamma &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & \\gamma & -2\\gamma\n \\end{pmatrix}}_A\\underbrace{\\begin{pmatrix} T_1^t\\\\ T_2^t\\\\ \\vdots\\\\ T_{N-1}^t \\end{pmatrix}}_{T(x,t)}\\\\\n \\frac{\\partial}{\\partial t}T(x,t)&=AT(x,t);\\qquad\\text{dengan }\\gamma=\\frac{D}{(\\Delta x)^2}\n \\end{align*}\n\nUngkapan matrik pada persamaan diferensial di atas mirip seperti bentuk persamaan diferensial orde satu bagi peubah bebas t yaitu \\frac{d}{dt}f(t)=c f(t) dengan penyelesaian berbentuk f(t)=e^{c t}f(0) untuk c adalah skalar.\n\nAnalog dengan bentuk penyelesaian tersebut maka penyelesaian persamaan diferensial bagi operasi matrik di atas akan berbentukT(x,t)=e^{At}T(x,0)\n\nBentuk eksplisit dalam operasi matrik bagi ungkapan di atas adalah\\begin{pmatrix}  T_1^t\\\\  T_2^t\\\\ \\vdots\\\\  T_{N-1}^t\\end{pmatrix}=exp\\left[\\begin{pmatrix}\n  -2\\gamma & \\gamma & 0 & \\cdots & 0 \\\\\n  \\gamma & -2\\gamma & \\gamma &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & \\gamma & -2\\gamma\n \\end{pmatrix}t\\right]\\begin{pmatrix} T_1^0\\\\ T_2^0\\\\ \\vdots\\\\ T_{N-1}^0 \\end{pmatrix}\n\nDari ungkapan di atas nampak bahwa penyelesaian persamaan diferensial parsial parabolik yang diwakili oleh persamaan difusi panas dapat dinyatakan dalam skema eksplisit seperti yang disajikan pada uraian sebelumnya, ketika bentuk operasi turunan satu kali terhadap waktu didekati dengan bentuk beda hingga maju (forward difference). Perbedaan antara skema eksplisit tersebut dengan skema eksplisit pada pendekatan beda hingga maju adalah pada bentuk matrik pada ruas kanan.\n\nPada ungkapan tersebut, bentuk matrik merupakan perwujudan dari operasi eksponensial terhadap suatu matrik A, bukan operasi eksponensial terhadap suatu skalar \\gamma. Operasi eksponensial terhadap suatu matrik biasa disebut sebagai eksponensial matrik.\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#komputasi-berdasar-ekponensial-matrik","position":23},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Komputasi Eksponensial Matrik"},"type":"lvl2","url":"/materi/penyelesaian-pers-diffusi-julia#komputasi-eksponensial-matrik","position":24},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl2":"Komputasi Eksponensial Matrik"},"content":"Untuk sebarang bentuk matrik A maka komputasi untuk eksponensial matrik e^A akan membutuhkan daya komputasi tinggi (demanding) karena akan melibatkan perkalian matrik A yang sangat besar, seperti dapat dilihat dalam ungkapan deret berikute^A=I+A+\\frac{1}{2!}A^2+\\cdots+\\frac{1}{n!}A^n+\\cdots\n\ndengan I adalah matrik identitas.\n\nOleh karena itu maka beberapa langkah komputasi perlu digunakan untuk dapat mendekati nilai dari eksponensial matrik. Salah metode komputasi yang umum dilakukan adalah dengan menggunakan pendekatan Pade (Pade approximation).\n\nSatu sifat khusus bagi eksponensial matrix apabila matrik A berbentuk matrik diagonal yaituA=\\begin{pmatrix}\n  a_{11} & 0 & \\cdots & 0 \\\\\n  0 & a_{22} & \\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & a_{NN} \n \\end{pmatrix}\n\nmaka bentuk eksponensial matrik akan sederhana berbentuk diagonal yaitue^A=\\begin{pmatrix}\n  e^{a_{11}} & 0 & \\cdots & 0 \\\\\n  0 & e^{a_{22}} & \\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & e^{a_{NN}} \n \\end{pmatrix}\n\nSifat ini sering dimanfaatkan untuk melakukan komputasi bagi matrik eksponensial berdasar pada prosedur diagonalisasi matrik dalam Aljabar Linear. Untuk matrik A yang berukuran tidak terlalu besar sedemikian hingga seluruh nilai eigen beserta vektor eigen dari matrik A akan dapat diperoleh, maka prosedur diagonalisasi matrik bagi matrik A akan berbentukA=UDU^{-1}\n\nMatrik diagonal D berisi nilai-nilai eigen dari matrik A pada unsur-unsur diagonalnya sedang matrik U berisi vektor-vektor eigen pada tiap kolom matrik.\n\nApabila proses diagonalisasi berhasil, yaitu matrik D dan matrik U dapat diperoleh, maka proses komputasi matrik eksponensial e^A akan menjadi lebih sederhana yaitu berbentuke^A=Ue^DU^{-1}\n\ndengan e^D akan berbentuk seperti pers (10b).\n\nSifat lain yang berguna bagi eksponensial matrik adalah bahwa transpose bagi matrik A^T akan terkait langsung dengan transpose bagi eksponensial matrik yaitue^{A^T}=\\left(e^A\\right)^T\n\nDapat ditunjukkan bahwa ungkapan yang lebih sesuai bagi ungkapan di atas adalah mengikuti apa yang disebut rumus Baker-Campbell-Hausdorff yaitue^{A}\\,e^{B}=e^{(A+B)+\\frac{1}{2}[A,B]+\\frac{1}{12}[A,[A,B]]+\\cdots}\n\nBerdasarkan persamaan tersebut akan mudah ditunjukkan bahwae^{A+B}\\neq e^A\\,e^B\n\nketika matrik A dan B adalah tidak komutatif, yaitu [A,B]\\neq 0.","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#komputasi-eksponensial-matrik","position":25},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Metode dekomposisi matrik Suzuki-Trotter","lvl2":"Komputasi Eksponensial Matrik"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#metode-dekomposisi-matrik-suzuki-trotter","position":26},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Metode dekomposisi matrik Suzuki-Trotter","lvl2":"Komputasi Eksponensial Matrik"},"content":"Untuk nilai parameter \\tau\\approx 0, Trotter menunjukkan bahwa pendekatan berikut akan berlakue^{\\tau A}\\,e^{\\tau B}=\\left[e^{\\left(\\frac{\\tau}{n}\\right) A}\\,e^{\\left(\\frac{\\tau}{n}\\right) B}\\right]^n=\\left[e^{\\left(\\frac{\\tau}{n}\\right)(A+B)+\\frac{1}{2}{\\left(\\frac{\\tau}{n}\\right)}^2[A,B]+\\frac{1}{12}{\\left(\\frac{\\tau}{n}\\right)}^3[A,[A,B]]+\\cdots}\\right]^n\\approx e^{\\tau(A+B)}\n\nAtau dapat ditulis pada pendekatan orde pertama sebagaie^{\\tau(A+B)}\\approx e^{\\tau A}\\,e^{\\tau B}\n\nSuzuki memperluas pendekatan Trotter di atas, sehingga disebut pendekatan dekomposisi Suzuki-Trotter, untuk orde dua yaitue^{\\tau(A+B)}\\approx e^{\\frac{\\tau}{2} A}\\,e^{\\tau B}\\,e^{\\frac{\\tau}{2} A}\n\nImplementasi pendekatan dekomposisi Suzuki-Trotter untuk penyelesaian persamaan difusi panas dapat dilakukan dengan meninjau bahwa proses difusi pada seluruh waktu t akan dilakukan secara diskret pada tiap selang waktu yang sangat kecil yaitu sebesar \\Delta t=\\tau dengan mengambil bahwa\\tau=\\Delta t=\\frac{t_N-t_0}{N}\n\nOleh karena itu sebarang waktu akan dapat dinyatakan sebagait\\approx t_N=t_{N-1}+\\Delta t=t_{N-2}+\\Delta t+\\Delta t=\\cdots=t_0+N\\Delta t=t_0+N\\tau\n\nPenyelesaian persamaan difusi panas akan dilakukan secara bertahap selama waktu kecil \\tau berdasar persamaan tersebut yaituT(x,\\tau)=e^{\\tau A} T(x,0)\n\nPerhitungan temperatur selama \\tau dapat memanfaatkan pendekatan dekomposisi Suzuki-Trotter orde satu atau orde dua berdasar dua persamaan yang disinggung sebelumnya.\n\nSebagai contoh, apabila menggunakan pendekatan orde satu dan matrik A akan dipisah berdasar sokongan dua matrik yang lebih sederhana yaitumatrik A_1 dan matrik A_2 maka persamaan tersebut berbentukT(x,\\tau)=e^{\\tau A} T(x,0)=e^{\\tau(A_1+A_2)}T(x,0)\\approx e^{\\tau A_1}e^{\\tau A_2} T(x,0)\n\nPada umumnya, operasi matrik yang terlibat pada komputasi eksponensial matrik tanpa dekomposisi akan membutuhkan ongkos komputasi tingi (demanding) dibanding operasi matrik yang melibatkan komputasi eksponensial matrik dekomposisi.\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#metode-dekomposisi-matrik-suzuki-trotter","position":27},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Implementasi metode dekomposisi eksponensial matrik untuk persamaan difusi panas","lvl2":"Komputasi Eksponensial Matrik"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#implementasi-metode-dekomposisi-eksponensial-matrik-untuk-persamaan-difusi-panas","position":28},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Implementasi metode dekomposisi eksponensial matrik untuk persamaan difusi panas","lvl2":"Komputasi Eksponensial Matrik"},"content":"Ditinjau keadaan ketika parameter \\tau adalah kecil yaitu \\tau=\\Delta t=\\frac{t_N-t_0}{N}. Untuk bentuk matrik A seperti dalam persamaan difusi panas maka ada beberapa tahap dekomposisi yang dapat dilakukan.\n\nTahat dekomposisi pertama\\underbrace{\\begin{pmatrix}\n  -2\\gamma & \\gamma & 0 & \\cdots & 0 \\\\\n  \\gamma & -2\\gamma & \\gamma &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & \\gamma & -2\\gamma\n\\end{pmatrix}}_A=\\underbrace{\\begin{pmatrix}\n  -2\\gamma & 0 & 0 & \\cdots & 0 \\\\\n  0 & -2\\gamma & 0 &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & 0 & -2\\gamma\n \\end{pmatrix}}_{A_1}+\\underbrace{\\begin{pmatrix}\n  0 & \\gamma & 0 & \\cdots & 0 \\\\\n  \\gamma & 0 & \\gamma &\\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & \\gamma & 0\n \\end{pmatrix}}_{A_2}\n\nTahap dekomposisi pertama dilakukan dengan beberapa pertimbangan yaitu\n\nMatrik A_1 dan A_2 bersifat komutatif yaitu [A_1,A_2]=A_1 A_2 - A_2 A_1=0.\n\nKarena bersifat komutatif maka berlaku kaitan berikute^A=e^{(A_1+A_2)}=e^{A_1}e^{A_2}\n\nMatrik A_1 berbentuk diagonal sehingga bentuk eksponensial matrik menjadi sederhana.e^{A_1}=\\begin{pmatrix}\n  e^{-2\\gamma} & 0 & \\cdots & 0 \\\\\n  0 & e^{-2\\gamma} & \\cdots & 0 \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  0 & \\cdots & 0 & e^{-2\\gamma} \n \\end{pmatrix}\n\nTahap dekomposisi kedua\\underbrace{\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 & \\cdots & 0 \\\\\n  \\gamma & 0 & \\gamma & 0 &\\cdots & 0 \\\\\n  0&\\gamma & 0 &\\gamma & \\cdots &0\\\\\n  \\vdots  & \\vdots  & \\vdots & \\ddots & \\cdots & \\vdots  \\\\\n    0 & \\cdots & 0 & \\gamma & 0 &\\gamma\\\\\n  0 & \\cdots & 0 & 0 & \\gamma & 0\n \\end{pmatrix}}_{A_2}=\\underbrace{\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 & \\cdots & 0 \\\\\n  0 & 0 & \\gamma & 0 &\\cdots & 0 \\\\\n  0&0 & 0 &\\gamma & \\cdots &0\\\\\n  \\vdots  & \\vdots  & \\vdots & \\ddots & \\cdots & \\vdots  \\\\\n    0 & \\cdots & 0 & 0 & 0 &\\gamma\\\\\n  0 & \\cdots & 0 & 0 & 0 & 0\n \\end{pmatrix}}_{A_3}+\\underbrace{\\begin{pmatrix}\n  0 & 0 & 0 & 0 & \\cdots & 0 \\\\\n  \\gamma & 0 & 0 & 0 &\\cdots & 0 \\\\\n  0&\\gamma & 0 &0 & \\cdots &0\\\\\n  \\vdots  & \\vdots  & \\vdots & \\ddots & \\cdots & \\vdots  \\\\\n    0 & \\cdots & 0 & \\gamma & 0 &0\\\\\n  0 & \\cdots & 0 & 0 & \\gamma & 0\n \\end{pmatrix}}_{A_4}\n\nUpaya untuk memperoleh eksponensial matrik bagi A_2 dengan melakukan dekomposisi terlebih dahulu bagi matrik A_2 menjadi penjumlahan matrik A_3 dan A_4 seperti di atas adalah dalam upaya agar proses pencarian eksponensial matrik A_2$ menjadi lebih sederhana. Penjelasan untuk itu dapat diberikan melalui gambaran berikut.\n\nBentuk matrik seperti A_3 atau A_4 disebut matrik nilpotent. Berdasar definisi yang disebut matrik nilpotent adalah suatu matrik A sedemikian hingga memenuhi A^k untuk k merupakan bilangan bulat tertentu. Sebagai gambaran, tinjau matrik A_3 dengan orde 4\\times 4. Maka dapat ditunjukkan operasi matrik berikut:\\begin{align*}\nA_3^2&=\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 \\\\\n  0 & 0 & \\gamma & 0 \\\\\n  0&0 & 0 &\\gamma\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 \\\\\n  0 & 0 & \\gamma & 0 \\\\\n  0&0 & 0 &\\gamma\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}=\\begin{pmatrix}\n  0 & 0& \\gamma^2 & 0 \\\\\n  0 & 0 & 0&\\gamma^2\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\\\\\n A_3^3&=\\begin{pmatrix}\n  0 & 0& \\gamma^2 & 0 \\\\\n  0 & 0 & 0&\\gamma^2\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 \\\\\n  0 & 0 & \\gamma & 0 \\\\\n  0&0 & 0 &\\gamma\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}=\\begin{pmatrix}\n  0 & 0& 0& \\gamma^3\\\\\n  0 & 0 & 0&0\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\\\\\nA_3^4&=\\begin{pmatrix}\n  0 & 0&0& \\gamma^3\\\\\n  0 & 0 & 0&0\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 \\\\\n  0 & 0 & \\gamma & 0 \\\\\n  0&0 & 0 &\\gamma\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}=\\begin{pmatrix}\n  0 & 0& 0& 0\\\\\n  0 & 0 & 0&0\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\n\\end{align*}\n\nDengan bentuk matrik nilpoten A_3 berorde 4 seperti di atas maka ungkapan eksponensial matrik bagi A_3 menjadi mudah untuk diperoleh yaitu\\begin{align*}\ne^{A_3}&=I+A_3+\\frac{1}{2}A_3^2+\\frac{1}{3!}A_3^3+\\frac{1}{4!}A_3^4+0=\\begin{pmatrix}\n  1 & 0& 0 & 0 \\\\\n  0 & 1 & 0&0\\\\\n  0&0 & 1 & 0\\\\\n   0 & 0 & 0 & 1\\end{pmatrix}+\\begin{pmatrix}\n  0 & \\gamma & 0 & 0 \\\\\n  0 & 0 & \\gamma & 0 \\\\\n  0&0 & 0 &\\gamma\\\\\n   0 & 0 & 0 & 0 \n \\end{pmatrix}\\\\\n&+\\frac{1}{2}\\begin{pmatrix}\n  0 & 0& \\gamma^2 & 0 \\\\\n  0 & 0 & 0&\\gamma^2\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0\\end{pmatrix}+\\frac{1}{3!}\\begin{pmatrix}\n  0 & 0& 0 & \\gamma^3 \\\\\n  0 & 0 & 0&0\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0\\end{pmatrix}+\\frac{1}{4!}\\begin{pmatrix}\n  0 & 0& 0& 0 \\\\\n  0 & 0 & 0&0\\\\\n  0&0 & 0 & 0\\\\\n   0 & 0 & 0 & 0\\end{pmatrix}+0\\\\\n  &=\\begin{pmatrix}\n  1 & \\gamma& \\frac{1}{2}\\gamma^2& \\frac{1}{6}\\gamma^3 \\\\\n  0 & 1 & \\gamma&\\frac{1}{2}\\gamma^2\\\\\n  0&0 & 1 & \\gamma\\\\\n   0 & 0 & 0 & 1\\end{pmatrix} \n\\end{align*}\n\nKarena A_4 merupakan transpose dari A_3 yaitu memenuhi kaitan A_4=A_3^T maka proses untuk memperoleh eksponensial matrik bagi A_4 menjadi sederhana yaitue^{A_4}=e^{A_3^T}=\\left(e^{A_3}\\right)^T=\\begin{pmatrix}\n  1 & \\gamma& \\frac{1}{2}\\gamma^2& \\frac{1}{6}\\gamma^3 \\\\\n  0 & 1 & \\gamma&\\frac{1}{2}\\gamma^2\\\\\n  0&0 & 1 & \\gamma\\\\\n   0 & 0 & 0 & 1\\end{pmatrix}^T=\\begin{pmatrix}\n  1 & 0& 0& 0 \\\\\n  \\gamma & 1 & 0&0\\\\\n  \\frac{1}{2}\\gamma^2&\\gamma & 1 & 0\\\\\n   \\frac{1}{6}\\gamma^3 & \\frac{1}{2}\\gamma^2 & \\gamma & 1\\end{pmatrix}\n\nDengan contoh tersebut maka prosedur untuk komputasi temperatur T(x,\\tau) berdasar eksponensial matrik dengan pendekatan Suzuki-Trotter orde 1 dilakukan dengan ungkapan berikut.\\begin{align*}\nT(x,\\tau)&=e^{\\tau A} T(x,0)=e^{\\tau(A_1+A_2)}T(x,0)= e^{\\tau A_1}e^{\\tau A_2} T(x,0)\\\\\n&=e^{\\tau A_1}e^{\\tau (A_3+A_4)} T(x,0)\\approx e^{\\tau A_1}e^{\\tau A_3}e^{\\tau A_4} T(x,0)\n\\end{align*}\n\nImplementasi bagi prosedur di atas dapat dilakukan dengan source-code berikut.\n\nusing LinearAlgebra\nusing Plots\nusing LaTeXStrings\n\n\n\n\nfunction exp_nilpotent(b)\n    n = length(b)\n    A = zeros(n+1, n+1)\n    A[end, end] = 1.0\n    for i in 1:n\n        A[i, i] = 1.0\n        l = 0\n        for j in i+1:n+1\n            l +=1\n            A[i, j] = A[i,j-1]*b[i]/l\n        end\n    end\n    return A\nend\n\n\n\nNx = 100\nNt = 100\nD = 1.0\n\nx = range(-5, 5, length = Nx)\nt = range(0, 10, length = Nt)\n\ndx = x[2] - x[1]\ndt = t[2] - t[1]\n\ngamma = D / dx^2\ntau = dt\nlambda = gamma * tau    \n\ntemper = zeros(Float64, Nx, Nt)\ntemper[:, 1] = exp.(-x.^2)\ntemper[1, :] .= 0.0\ntemper[end, :] .= 0.0;    \n\n\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#implementasi-metode-dekomposisi-eksponensial-matrik-untuk-persamaan-difusi-panas","position":29},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Pendekatan Suzuki-Trotter orde 1","lvl2":"Komputasi Eksponensial Matrik"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#pendekatan-suzuki-trotter-orde-1","position":30},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Pendekatan Suzuki-Trotter orde 1","lvl2":"Komputasi Eksponensial Matrik"},"content":"\n\nb = lambda * ones(Nx-3);\n\n\n\nA3 = exp_nilpotent(b);\n\n\n\nfunction skema_ExpMat1(A3, temper, lambda, Nt, Nx)\n    A4 = transpose(A3)\n    d = exp(-2.0 * lambda) * ones(Nx-2)\n    A1 = diagm(d)\n    evolusi = zeros(Nx-2, Nx-2)\n    evolusi = A1 * A3 * A4\n    for i in 2:Nt             \n        temper[2:Nx-1,i] =  evolusi * temper[2:Nx-1,i-1]\n    end\n\n    return temper\nend\n\n\n\ntemper1 = skema_ExpMat1(A3, temper, lambda, Nt, Nx);\n\n\n\nplot(x, [temper1[:, 100],temper1[:, 10], temper1[:, 1]],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#pendekatan-suzuki-trotter-orde-1","position":31},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Pendekatan Suzuki-Trotter orde 2","lvl2":"Komputasi Eksponensial Matrik"},"type":"lvl3","url":"/materi/penyelesaian-pers-diffusi-julia#pendekatan-suzuki-trotter-orde-2","position":32},{"hierarchy":{"lvl1":"Penyelesaian Persamaan Diferensial Parsial Parabolik","lvl3":"Pendekatan Suzuki-Trotter orde 2","lvl2":"Komputasi Eksponensial Matrik"},"content":"\n\nb = 0.5 * lambda * ones(Nx-3);\n\n\n\nA3 = exp_nilpotent(b);\n\n\n\nfunction skema_ExpMat2(A3, temper, lambda, Nt, Nx)\n    A4 = transpose(A3)\n    d = exp(-2.0 * lambda) * ones(Nx-2)\n    A1 = diagm(d)\n    evolusi = zeros(Nx-2, Nx-2)\n    evolusi = A1 * transpose(A3 * A4) * A3 * A4\n    for i in 2:Nt             \n        temper[2:Nx-1,i] =  evolusi * temper[2:Nx-1,i-1]\n    end\n\n    return temper\nend\n\n\n\ntemper2 = skema_ExpMat2(A3, temper, lambda, Nt, Nx);\n\n\n\nplot(x, [temper2[:, 50],temper2[:, 10], temper2[:, 1]],\n     xlabel=L\"$x$\",\n     ylabel=L\"$T(x,t)$\",\n     title=\"Plot\")\n\n\n\ncontour(x, t, temper',\n        xlabel=L\"$x$\",\n        ylabel=L\"$t$\",\n        title=\"Contour Plot\",\n        fill=true)\n     \n\n\n\nsurface(x, t, temper',\n        xlabel=L\"$x$\",\n        ylabel=L\"$t$\",\n        zlabel=L\"$T(x,t)$\",\n        title=\"Surface Plot\")\n\n","type":"content","url":"/materi/penyelesaian-pers-diffusi-julia#pendekatan-suzuki-trotter-orde-2","position":33},{"hierarchy":{"lvl1":"Komputasi Fisika"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Komputasi Fisika"},"content":"Materi yang disajikan disini merupakan materi kuliah di Program Studi S1 Fisika FMIPA UGM dengan nama matakuliah \n\nKomputasi Fisika.\n\nMateri dapat dilihat pada \n\ntautan berikut atau bentuk  \n\nsource code.\n\nMateri ini mengikuti lisensi LGPL-3.0-or-later","type":"content","url":"/","position":1}]}